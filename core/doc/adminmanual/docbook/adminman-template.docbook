<?xml version="1.0" encoding="UTF-8"?><book xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" label="UMS.apim#MAN(admin);UMS.apim#CPP(admin);UMS.apim#PYTHON(admin);IMS.apim#MAN(admin);IMS.apim#CPP(admin);IMS.apim#PYTHON(admin)" xsi:noNamespaceSchemaLocation="http://docbook.org/ns/docbook">
<!--<book xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://docbook.org/ns/docbook">-->
<info>
<title>VISHNU - Le guide de l'administrateur</title>
<author>
<personname><firstname>Benjamin</firstname><surname>Isnard</surname></personname>
</author>
<author>
<personname><firstname>Daouda</firstname><surname>Traoré</surname></personname>
</author>
<author>
<personname><firstname>Eugène</firstname><surname>Pamba Capo-Chichi</surname></personname>
</author>
<author>
<personname><firstname>Kevin</firstname><surname>Coulomb</surname></personname>
</author>
<author>
<personname><firstname>Ibrahima</firstname><surname>Cissé</surname></personname>
</author>
<author>
<personname><firstname>Rodrigue</firstname><surname>Chakode</surname></personname>
</author>
<author>
<personname><firstname>Benjamin</firstname><surname>Depardon</surname></personname>
</author>
<author>
<personname><firstname>Haïkel</firstname><surname>Guémar</surname></personname>
</author>
<author>
<personname><firstname>Amine</firstname><surname>Bsila</surname></personname>
</author>
<revhistory>
<revision>
<revnumber>1</revnumber>
<date>08/03/2011</date>
<authorinitials>K. COULOMB</authorinitials>
<revdescription>
<para>Version initiale pour le module UMS uniquement</para>
</revdescription>
</revision>
<revision>
<revnumber>2</revnumber>
<date>18/03/2011</date>
<authorinitials>K. COULOMB</authorinitials>
<revdescription>
<para>Ajout du lancement manuel avec forwarder et d'image de fichiers de configuration exemple</para>
</revdescription>
</revision>
<revision>
<revnumber>3</revnumber>
<date>22/03/2011</date>
<authorinitials>K. COULOMB</authorinitials>
<revdescription>
<para>Ajout des web services</para>
</revdescription>
</revision>
<revision>
<revnumber>4</revnumber>
<date>11/05/2011</date>
<authorinitials>K. COULOMB, B.ISNARD</authorinitials>
<revdescription>
<para>Réécriture du lancement avec fichier de configuration.</para>
<para>Ajout d'un paragraphe pour le sendmail.</para>
<para>Ajout de l'administration de TMS.</para>
</revdescription>
</revision>
<revision>
<revnumber>5</revnumber>
<date>18/05/2011</date>
<authorinitials>B.ISNARD</authorinitials>
<revdescription>
<para>Ajout du parametre de configuration dbConnectionsNb.</para>
</revdescription>
</revision>
<revision>
<revnumber>6</revnumber>
<date>10/06/2011</date>
<authorinitials>K.COULOMB</authorinitials>
<revdescription>
<para>Documentation pour IMS.</para>
</revdescription>
</revision>
<revision>
<revnumber>7</revnumber>
<date>15/06/2011</date>
<authorinitials>I.CISSE</authorinitials>
<revdescription>
<para>Documentation pour FMS.</para>
</revdescription>
</revision>
<revision>
<revnumber>8</revnumber>
<date>22/06/2011</date>
<authorinitials>B.ISNARD</authorinitials>
<revdescription>
<para>Ajout de l'option ENABLE_SWIG.</para>
</revdescription>
</revision>

<revision>
<revnumber>9</revnumber>
<date>24/06/2011</date>
<authorinitials>I.CISSE</authorinitials>
<revdescription>
<para>Ajout de l'option vishnuMachineId dans les fichiers de
configuration de UMS, IMS et FMS .</para>
</revdescription>
</revision>
<revision>
<revnumber>10</revnumber>
<date>13/07/2011</date>
<authorinitials>K.COULOMB</authorinitials>
<revdescription>
<para>Mise à jour du document suites aux premiers retours .</para>
</revdescription>
</revision>
<revision>
<revnumber>11</revnumber>
<date>11/08/2011</date>
<authorinitials>D.TRAORE</authorinitials>
<revdescription>
<para>Prise en compte du gestionnaire de resources SLURM</para></revdescription>
</revision>

<revision>
<revnumber>12</revnumber>
<date>23/08/2011</date>
<authorinitials>K.COULOMB</authorinitials>
<revdescription>
<para>Ajout d'un lien sur des sites expliquant comment installer une base de
données postgresql/mysql. Suppression des informations de mise à jour de la
base (maintenant le script de création contient tout). Ajout d'une
référence vers 'VISHNU_API'</para></revdescription>
</revision>

<revision>
<revnumber>13</revnumber>
<date>14/12/2011</date>
<authorinitials>K.COULOMB</authorinitials>
<revdescription>
<para>
Mise à jour pour les nouveaux forwarder de DIET.
</para></revdescription>
</revision>


<revision>
<revnumber>14</revnumber>
<date>15/12/2011</date>
<authorinitials>I.CISSE</authorinitials>
<revdescription>
<para>
Mise à jour de la section configuration des clés ssh requises pour FMS.
</para></revdescription>
</revision>

<revision>
<revnumber>15</revnumber>
<date>16/12/2011</date>
<authorinitials>D.TRAORE</authorinitials>
<revdescription>
<para>
Ajout de la section configuration des clés ssh requises pour TMS.
</para></revdescription>
</revision>
<revision>
<revnumber>16</revnumber>
<date>30/01/2012</date>
<authorinitials>K. COULOMB</authorinitials>
<revdescription>
<para>
Modifie les requirements en fonction de la version de DIET
</para></revdescription>
</revision>
<revision>
<revnumber>17</revnumber>
<date>27/02/2012</date>
<authorinitials>K. COULOMB</authorinitials>
<revdescription>
<para>
Liste les libs de boost nécessaire
</para></revdescription>
</revision>
<revision>
<revnumber>18</revnumber>
<date>02/03/2012</date>
<authorinitials>D.TRAORE</authorinitials>
<revdescription>
<para>Prise en compte du gestionnaire de resources LSF</para></revdescription>
</revision>
<revision>
<revnumber>19</revnumber>
<date>22/03/2012</date>
<authorinitials>K. COULOMB</authorinitials>
<revdescription>
<para>Ajout pour le support de LDAP</para></revdescription>
</revision>

<revision>
<revnumber>20</revnumber>
<date>11/04/2012</date>
<authorinitials>E. PAMBA CAPO-CHICHI</authorinitials>
<revdescription>
<para>Prise en compte du gestionnaire de resources Grid Engine</para></revdescription>
</revision>

<revision>
<revnumber>21</revnumber>
<date>30/05/2012</date>
<authorinitials>E. PAMBA CAPO-CHICHI</authorinitials>
<revdescription>
<para>Ajout des versions de LoadLeveler, GLIBC pour libcrypt et ssh</para></revdescription>
</revision>

<revision>
<revnumber>22</revnumber>
<date>27/08/2012</date>
<authorinitials>K. COULOMB</authorinitials>
<revdescription>
<para>Nouvelle compilation avec les batchs</para></revdescription>
</revision>

<revision>
<revnumber>23</revnumber>
<date>01/10/2012</date>
<authorinitials>R. Chakode</authorinitials>
<revdescription>
<para>Ajout des prérequis en termes de connaissances systèmes et raffinement
de la procédure d'installation</para></revdescription>
</revision>

<revision>
<revnumber>24</revnumber>
<date>08/11/2012</date>
<authorinitials>K. COULOMB</authorinitials>
<revdescription>
<para>Ajout d'un paragraphe sur l'utilisation d'une base de données distante</para></revdescription>
</revision>

<revision>
<revnumber>25</revnumber>
<date>08/11/2012</date>
<authorinitials>A. BSILA</authorinitials>
<revdescription>
<para>Prise en compte du gestionnaire de resources PBSPro</para></revdescription>
</revision>

<revision>
<revnumber>26</revnumber>
<date>21/11/2012</date>
<authorinitials>K. Coulomb</authorinitials>
<revdescription>
<para>Première MAJ pour ZeroMQ</para></revdescription>
</revision>

<revision>
<revnumber>27</revnumber>
<date>04/01/2013</date>
<authorinitials>B. Depardon</authorinitials>
<revdescription>
<para>Maj documentation du dispatcher</para></revdescription>
</revision>

<revision>
<revnumber>28</revnumber>
<date>15/01/2013</date>
<authorinitials>H. Guémar</authorinitials>
<revdescription>
<para>
Ajout d'une FAQ pour la résolution des problèmes d'administration.
Ajout d'une entrée dans la FAQ à propos du chargement des plugins TMS
</para>
</revdescription>
</revision>

<revision>
<revnumber>29</revnumber>
<date>15/01/2013</date>
<authorinitials>R. Chakode</authorinitials>
<revdescription>
<para>Mise à jour des dépendences d'installation avec ZeroMQ et
suppression du chapite lié aux web services</para>
</revdescription>
</revision>

<revision>
<revnumber>30</revnumber>
<date>28/01/2013</date>
<authorinitials>A. Bsila</authorinitials>
<revdescription>
<para>Présentation des tests automatiques</para>
</revdescription>
</revision>

<revision>
<revnumber>31</revnumber>
<date>26/02/2013</date>
<authorinitials>R. Chakode</authorinitials>
<revdescription>
<para>Ajout documentation pour le support des gestionnaires de cloud</para>
</revdescription>
</revision>

<revision>
<revnumber>32</revnumber>
<date>14/05/2013</date>
<authorinitials>R. Chakode</authorinitials>
<revdescription>
<para>Ajout documentation pour le chiffrement des connexions à la base de données MySQL </para>
</revdescription>
</revision>

<revision>
<revnumber>33</revnumber>
<date>16/05/2013</date>
<authorinitials>R. Chakode</authorinitials>
<revdescription>
<para>Ajout documentation pour le chiffrement des connexions à la base de données PostGreSQL </para>
</revdescription>
</revision>

<revision>
<revnumber>34</revnumber>
<date>13/06/2013</date>
<authorinitials>R. Chakode</authorinitials>
<revdescription>
<para>Ajout documentation pour le chiffrement des communications entre les clients et les SeDs</para>
</revdescription>
</revision>

<revision>
<revnumber>35</revnumber>
<date>21/10/2013</date>
<authorinitials>R. Chakode</authorinitials>
<revdescription>
<para>Ajout d'informations liées au support d'OpenNebula</para>
</revdescription>
</revision>

<revision>
<revnumber>36</revnumber>
<date>08/11/2013</date>
<authorinitials>K. Coulomb</authorinitials>
<revdescription>
<para>Ajout du support de SWIG2 et python2.7, mise à jour concernant les clés SSH.</para>
</revdescription>
</revision>

</revhistory>
</info>
<chapter>
<title>Présentation du document</title>
<section>
<title>Objectifs du document</title>
<para>
Ce document décrit l'installation, la configuration et l'administration
des différents composants de la suite logicielle VISHNU.
</para>
</section>

<section>
<title>Prérequis</title>
<para>
Pour s'assurer un bon confort lors de la lecture de ce document, le lecteur
doit au moins avoir des connaissances basiques en administration système
en environnement GNU/Linux. En particulier et selon votre système d'exploitation,
la maitrise d'un outil de gestion de paquets tels que
<emphasis>apt-get</emphasis>, <emphasis>dpkg</emphasis>, <emphasis>rpm</emphasis>,
<emphasis>yum</emphasis> ou <emphasis>zypper</emphasis>
est vivement recommandée pour faciliter la recherche et l'installation des
dépendances logicielles de VISHNU.
</para>
<para>Par ailleurs, vous devez avoir bien compris l'architecture de déploiement
de VISHNU. Cf. chapitre 4 du document [ARCH].</para>
</section>

<section><!--Document structure -->
<title>Structure du document</title>

<para>Ce document contient les parties suivantes:
</para>
<para>
<itemizedlist>
<listitem>
<para>Définitions</para>
</listitem>
<listitem>
<para>Installation</para>
</listitem>
<listitem>
<para>Déploiement</para>
</listitem>
<listitem>
<para>Administration</para>
</listitem>
<listitem>
<para>Référence des commandes (en anglais)</para>
</listitem>
<listitem>
<para>Référence de l'API C++ (en anglais)</para>
</listitem>
<listitem>
<para>Référence de l'API Python (en anglais)</para>
</listitem>
</itemizedlist>
</para>
</section> <!--Document structure -->

<section>
<title>Documents de références</title>
<itemizedlist>
<listitem>
<para>[ARCH] D1.1g-VISHNU Technical Architecture : description de l'architecture de l'application VISHNU</para>
</listitem>
<listitem>
<para>[VISHNU_USERMANUAL] VISHNU User Manual : guide de l'utilisateur VISHNU.</para>
</listitem>
<listitem>
<para>[VISHNU_API] VISHNU API : API VISHNU contenant les signatures et la définition des objets.</para>
</listitem>
</itemizedlist>
</section>

</chapter>

<chapter><!--Glossaire -->
<title>Acronymes et Glossaire</title>
<section><!-- Accronymes -->
<title>Terminologies</title>
<itemizedlist>
<listitem>
<para>Sysfera-DS : Désigne la suite logiciel développée par SysFera
pour simplifier et l'utilisation des ressources de calcul à grande échelle.
La suite comprend VISHNU et le WebBoard.
</para>
</listitem>
<listitem>
<para>VISHNU est une boite à outil qui permet la fédération et l'accès unifié
à des plateformes de calcul distribués (clusters, grilles et cloud).
</para>
</listitem>
<listitem>
<para>FMS (File Management Service): désigne le système de gestion de données dans
VISHNU.</para>
</listitem>
<listitem>
<para>IMS (Information Management Service): désigne le système de gestion
d'information dans VISHNU.</para>
</listitem>
<listitem>
<para>TMS : Task Management Service ou système de gestion de tâches</para>
</listitem>
<listitem>
<para>UMS : User Management Service ou système de gestion des utilisateurs</para>
</listitem>
<listitem>
<para>SeD FMS : désigne l'exécutable qui supporte le service FMS. </para>
</listitem>
<listitem>
<para>SeD IMS : désigne l'exécutable qui supporte le service VISHNU. </para>
</listitem>
<listitem>
<para>SeD TMS : désigne l'exécutable qui supporte le service TMS. </para>
</listitem>
<listitem>
<para>SeD UMS : désigne l'exécutable qui supporte le service UMS. </para>
</listitem>
<listitem>
<para>Client FMS : désigne l'ensemble des programmes pour accéder
aux services FMS. </para>
</listitem>
<listitem>
<para>Client IMS : désigne l'ensemble des programmes pour accéder aux services IMS. </para>
</listitem>
<listitem>
<para>Client TMS : désigne l'ensemble des programmes qui permettent d'accéder
aux services offerts par le Sed TMS. </para>
</listitem>
<listitem>
<para>Client UMS : désigne l'ensemble pour accéder aux services UMS. </para>
</listitem>
<listitem>
<para>
Dispatcher: est un composant de VISHNU ayant pour rôle de simplifier la configuration
des clients dans des achitectures complexes. Comme décrit dans le document d'architecture [ARCH],
il sert de broker entre les clients et différents batch schedulers dont il rend
l'accès transparent pour les utilisateurs.
</para>
</listitem>
<listitem>
<para>
Supervisord est un outil de supervision externe que l'on peut intégrer dans
l'environnement de déploiement pour contrôler le démarrage, l'arrêt et le
redemarrage automatique des services.
</para>
</listitem>
<listitem>
<para>LDAP : Lightweight Directory Access Protocol, est un protocole de gestion
d'annuaires.</para>
</listitem>
<listitem>
<para>SQL (Structured Query Language) : est un langage avancée de requêtes sur
les bases de données.</para>
</listitem>
<listitem>
<para>ZeroMQ aussi appelé ZMQ est une bibliothèque de communication par passage
de messages asynchrones utilisé dans VISHNU pour assurer la communication entre
les différents composants (clients, SeD et Dispatcher).</para>
</listitem>
<listitem>
<para>Préfrontale : c'est une machine mise en amont des frontales des serveurs de calcul. </para>
</listitem>
</itemizedlist>
</section> <!-- Glossaire -->
</chapter><!-- end Definition -->


<chapter>
<title>Installation à partir des sources</title>
<para>Ce chapitre décrit l'installation de VISHNU à partir des sources.
</para>
<section>
<title>Prérequis</title>
<para>La compilation nécessite les bibliothèques suivantes :
</para>
<itemizedlist>
<listitem>
<para><emphasis role="bold">Dépendances obligatoires</emphasis></para>
<itemizedlist>
<listitem>
<para>GCC : Version 4.4.3 ou ultérieure.</para>
</listitem>
<listitem>
<para>CMAKE : Version 2.8 ou ultérieure.</para>
<para>GNU Make ou Ninja: Générateurs exécutables. Comme alternative à Make, le générateur Ninja
est plus rapide et est utile pour réduire la durée de compilation.Surtout quand vous avez besoin
de compiler plusieurs modules de VISHNU sur la même machine.
</para>
</listitem>
<listitem>
<para>BOOST 1.46.1 ou ultérieure. Au moins les modules <emphasis>program_options</emphasis>, 
<emphasis>date_time, thread, filesystem, system, unit_test_framework, serialization, random</emphasis> 
et <emphasis>regex</emphasis> doivent être installés
</para>
</listitem>
<listitem>
<para>ZeroMQ 2.x. Non supporté avec les versions 3.x</para>
</listitem>
<listitem>
<para>libuuid : est une dépendance de ZeroMQ</para>
</listitem>
<listitem>
<para>GLIBC 2.7 ou ultérieure</para>
</listitem>
<listitem>
<para>OpenSSH 4.2 ou ultérieure</para>
</listitem>
<listitem>
<para>Moteur de base de données :</para>
<itemizedlist>
<listitem>
<para>PostGreSQL 8.0 minimum, ou</para>
</listitem>
<listitem>
<para>MySQL 5.1 minimum</para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para><emphasis role="bold">Dépendances spécifiques pour le module UMS</emphasis></para>
<itemizedlist>
<listitem>
<para>OpenLDAP 2.4 ou ultérieure</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para><emphasis role="bold">Dépendances spécifiques pour IMS</emphasis></para>
<itemizedlist>
<listitem>
<para>Sigar 1.6.4 disponible sur sourceforge (http://sourceforge.net/projects/sigar/files/sigar/1.6/)</para>
</listitem>
<listitem>
<para>Supervisord 3.0.a, installable à partir des outils Python (ex. pip install supervisor)</para>
</listitem>
<listitem>
<para>Xmlrpc-c 2.1.19
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para><emphasis role="bold">Dépendances spécifiques aux batch schedulers</emphasis></para>
<para>Sauf indication contraire, seules les versions indiquées sont officiellement supportées car ayant fait l'objet de tests. </para>
<itemizedlist>
<listitem>
<para>Torque 2.3.6</para>
</listitem>
<listitem>
<para>IBM LoadLeveler 2.x ou 3.x</para>
</listitem>
<listitem>
<para>SLURM 2.2.x, 2.3.x ou 2.4.x</para>
</listitem>
<listitem>
<para>LSF 7.0.6.134609</para>
</listitem>
<listitem>
<para>Grid Engine 2011.11</para>
</listitem>
<listitem>
<para>PBSPro 10.4</para>
</listitem>
<listitem>
<para>Detalcloud 1.x. Le support de Deltacloud nécessite la bibliothèque Libdeltacloud Client pour C et C++, version 0.9 ou supérieure.</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para><emphasis role="bold">Dépendences nécessaires à la génération des APIs Python et Java</emphasis></para>
<itemizedlist>
<listitem>
<para>SWIG 1.3.40 ou SWIG 2.0 (les 2 versions sont supportées).</para>
</listitem>
<listitem>
<para>JAVA SDK 1.6.</para>
</listitem>
<listitem>
<para>Python 2.7</para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section><!-- end prerequis -->
<section>
<title>Compilation des sources </title>
<para>
VISHNU utilise CMake comme système de construction. Les différentes fonctionnalités
sont activées ou désactivées à la demande grâce à des variables Cmake spécifiques.
Positionnée à <emphasis>ON</emphasis> une variable permet d'activer la fonctionnalité
associée. Ex. -DCOMPILE_UMS=ON active la compilation du module UMS.
Un positionnement à <emphasis>OFF</emphasis> désactive la compilation de la fonctionnalité.
Ex. -DCOMPILE_UMS=ON désactive la compilation du module UMS.
</para>
<para>
Dans certains cas on peut avoir besoin de mots-clés spécifiques pour activer une fonctionnalité.
Ex. -DVISHNU_BATCH=SLURM permet de sélectionner SLURM comme batch scheduler sous-jacent à TMS.
</para>
<para>
La liste ci-dessous décrit les variables disponibles :
<itemizedlist>
<listitem>
<para>
COMPILE_CLIENT_CLI permet, si on le souhaite, de compiler les binaires clients en ligne de commande.
Par défault seules les libs sont compilées.
</para>
</listitem>
<listitem>
<para>
COMPILE_SERVERS permet si on le souhaite de compiler les serveurs.
Par défault ils ne sont pas compilés.
</para>
</listitem>
<listitem>
<para>
CMAKE_INSTALL_PREFIX définit le répertoire d'installation. Par défault l'installation est
réalisée dans <emphasis>/usr/local</emphasis>.
</para>
</listitem>
<listitem>
<para>COMPILE_UMS indique si le module UMS sera compilé.</para>
<para>Ce module est activé par défault (-DCOMPILE_UMS=ON).
</para>
</listitem>
<listitem>
<para>
COMPILE_FMS spécifie si le module FMS sera compilé. </para>
<para>FMS est désactivé par défaut (-DCOMPILE_FMS=OFF),
lorsqu'il est activé le module COMPILE_UMS dont il dépend doit être également activé (-DCOMPILE_UMS=ON).
</para>
</listitem>
<listitem>
<para>
COMPILE_TMS permet de préciser si le module TMS sera compilé. </para>
<para>
Par défaut désactivé, si TMS est activé (-DCOMPILE_TMS=ON), alors les modules UMS et FMS dont il
dépend doivent être égalements activés (-DCOMPILE_UMS=ON et -DCOMPILE_FMS=ON).
</para>
<para>Par ailleurs lorsque TMS est activé, on doit obligatoirement sélectionner un batch scheduler
grâce aux options VISHNU_BATCH et VISHNU_BATCH_VERSION (ex. VISHNU_BATCH=SLURM et VISHNU_BATCH_VERSION=2.2).
</para>
</listitem>
<listitem>
<para>
COMPILE_IMS indique si le module IMS sera compilé. </para>
<para>IMS est désactivé par défaut. Lorsqu'il est activé, tous les autres modules doivent
l'être également (-DCOMPILE_UMS=ON, -DCOMPILE_TMS=ON et -DCOMPILE_FMS=ON).
</para>
</listitem>

<listitem>
<para>
ENABLE_PYTHON : Désactivée par défaut cette option permet d'activer ou non la compilation du code PYTHON pour PYTHON 2.7.
</para>
</listitem>

<listitem>
<para>
ENABLE_PYTHON3 : Désactivée par défaut cette option permet d'activer ou non la compilation du code PYTHON pour PYTHON 3.3 (expérimental).
</para>
</listitem>

<listitem>
<para>
ENABLE_JAVA : Désactivée par défaut cette option permet d'activer ou non la compilation du code JAVA.
</para>
</listitem>
<listitem>
<para>
ENABLE_LDAP permet d'activer le support LDAP pour l'authentification. Cette option est désactivée par défaut.
</para>
</listitem>
<listitem>
<para>
ENABLE_SWIG permet d'activer la generation du code des adapteurs PYTHON et JAVA.
</para>
<para>Désactivée par défaut cette option doit obligatoirement être activée si on choisit de ne pas compiler
tous les modules VISHNU. C'est-à-dire lorsqu'au moins l'une des options COMPILE_UMS, COMPILE_TMS, COMPILE_FMS
ou COMPILE_IMS est à OFF. Par ailleurs, l'activation de cette option nécessite que SWIG ait été installé au préalable.
</para>
</listitem>
<listitem>
<para>VISHNU_BATCH indique le batch scheduler à activer (TORQUE par défaut).</para>
<para>Selon l'installation de votre batch scheduler et la configuration de votre système, il peut être nécessaire de 
positionner manuellement des variables cmake supplémentaires pour faciliter la recherche des fichier d'entête et les 
bibliothèques dynamiques ou statiques nécessaires à la compilation et l'édition de liens. 
Leurs valeurs doivent être des chemins absolus. Ainsi:</para>
<itemizedlist>
<listitem>
<para>
Pour le scheduler Tivoli LoadLeveler, LOADLEVELER_INCLUDE_DIR doit pointer vers le repertoire contenant le fichier llapi.h tandis que LOADLEVELER_LIB 
doit pointer vers le fichier libllapi.so ou le fichier le libllapi.a.
</para>
</listitem>
<listitem>
<para>
Pour TORQUE, la variable TORQUE_INCLUDE_DIR doit pointer vers le dossier contenant le fichier pbs_ifl.h tandis que TORQUE_LIB doit pointer 
vers le fichier libtorque.so ou le fichier libtorque.a.
</para>
</listitem>
<listitem>
<para>
Pour SLURM, la variable SLURM_INCLUDE_DIR doit pointer vers le repertoire contenant slurm/slurm.h tandis que SLURM_LIB doit pointer vers le chemin absolu 
du libslurm.so ou le fichier libslurm.a.
</para>
</listitem>
<listitem>
<para>
Pour LSF, les variables LSF_INCLUDE_DIR, LSBATCH_LIB et LSBATCH_LIB doivent être définies. La variable LSF_INCLUDE_DIR doit pointer vers 
le chemin absolu du repertoire contenant le fichier lsf/lsbatch.h, LSBATCH_LIB doit pointer vers le chemin absolu du fichier libbat.so ou du fichier libbat.a. 
Tandis que la variable LSBATCH_LIB doit pointer vers la bibliothèque libbat.so ou libbat.so.
</para>
</listitem>
<listitem>
<para>
Pour les Batch schedulers basés sur Grid Engine, les variables SGE_ROOT, SGE_INCLUDE_DIR, SGE_BIN_DIR, SGE_BIN_DIR et SGE_LIB doivent être défines. 
La valeur de SGE_ROOT doit à la racine du dossier d'installation du batch scheduler; SGE_INCLUDE_DIR doit pointer vers le dossier contenant le fichier d'entête 
drmaa.h; SGE_BIN_DIR doit pointer vers le repertoire contenant les fichiers binaires. tandis que SGE_LIB doit pointer vers la bibliothèque libdrmaa.so ou libdrmaa.a.
</para>
</listitem>
<listitem>
<para>
Pour PBS PRO, les variables PBS_INCLUDE_DIR et PBS_LIB doivent être défines comme suit. PBS_INCLUDE_DIR doit pointer vers le repertoire contenant le fichier 
d'entête pbs_ifl.h, tandis que PBS_LIB doit pointer vers la bibliothèque libpbs.so ou libpbs.a.
</para>
</listitem>
<listitem>
<para>
Pour Deltacloud, les variables LIBDELTACLOUD_INCLUDE_DIR et LIBDELTACLOUD_LIB doivent être défines comme suit. LIBDELTACLOUD_INCLUDE_DIR doit 
pointer vers le repertoire contenant les fichiers d'entête de LibDeltacloud, tandis que LIBDELTACLOUD_LIB doit pointer vers la bibliothèque libdeltacloud.so 
ou libdeltacloud.a.
</para>
</listitem>
</itemizedlist>

</listitem>
<listitem>
<para>
VISHNU_BATCH_VERSION indique la version du batch scheduler utilisé
</para>
</listitem>

<listitem>
<para>
BUILD_TESTING: Désactivée par défaut, cette variable spécifie si le module de test sera compilé.
</para>
</listitem>

</itemizedlist>
</para>
<para>
Ci-dessous nous décrirons les étapes pour installer les clients et les serveurs d'UMS et TMS dans /opt/vishnu.
TORQUE est utilisé comme backend à TMS. La compilation des APIs Python sera également activée.
</para>
<itemizedlist>
<listitem>
<para>1. Créer un répertoire build à la racine du projet et s'y placer</para>
<para>$ <emphasis>mkdir build</emphasis></para>
<para>$ <emphasis>cd build</emphasis></para>
</listitem>
<listitem><para>2. Générer le Makefile </para>
<itemizedlist>
<listitem><para>En utilisant Make</para>
<para>$ <emphasis>cmake -DCMAKE_INSTALL_PREFIX=/opt/vishnu .. \</emphasis></para>
<para><emphasis>-DENABLE_SWIG=ON \</emphasis></para>
<para><emphasis>-DENABLE_PYTHON=ON \</emphasis></para>
<para><emphasis>-DCOMPILE_UMS=ON \</emphasis></para>
<para><emphasis>-DCOMPILE_TMS=ON \</emphasis></para>
<para><emphasis>-DVISHNU_BATCH=TORQUE \</emphasis></para>
<para><emphasis>-DVISHNU_BATCH_VERSION=2.3 \</emphasis></para>
<para><emphasis>-DTORQUE_DIR=/opt/torque</emphasis></para>
<para><emphasis>-DCOMPILE_CLIENT_CLI=ON</emphasis></para>
<para><emphasis>-DCOMPILE_SERVERS=ON</emphasis></para>
</listitem>
<listitem><para>En utilisant Ninja : changement du générateur via le flag CMAKE_GENERATOR.</para>
<para>$ <emphasis>cmake -DCMAKE_INSTALL_PREFIX=/opt/vishnu .. \</emphasis></para>
<para><emphasis>-DENABLE_SWIG=ON \</emphasis></para>
<para><emphasis>-DENABLE_PYTHON=ON \</emphasis></para>
<para><emphasis>-DCOMPILE_UMS=ON \</emphasis></para>
<para><emphasis>-DCOMPILE_TMS=ON \</emphasis></para>
<para><emphasis>-DVISHNU_BATCH=TORQUE \</emphasis></para>
<para><emphasis>-DVISHNU_BATCH_VERSION=2.3 \</emphasis></para>
<para><emphasis>-DTORQUE_DIR=/opt/torque \</emphasis></para>
<para><emphasis>-DCOMPILE_CLIENT_CLI=ON</emphasis></para>
<para><emphasis>-DCOMPILE_SERVERS=ON</emphasis></para>
<para><emphasis role="bold">-DCMAKE_GENERATOR=Ninja</emphasis></para>
</listitem>
</itemizedlist>
</listitem>
<listitem><para>3. Lancer la compilation</para>
<itemizedlist>
<listitem><para>En utilisant Make</para>
<para>$ <emphasis>make -j 2</emphasis></para>
<para>L'option -j 2 permet de lancer la compilation avec deux processus</para>
</listitem>
<listitem><para>En utilisant Ninja</para>
<para>$ <emphasis>ninja -j 2</emphasis></para>
<para>L'option -j 2 permet de lancer la compilation avec deux processus</para>
</listitem>
</itemizedlist>
</listitem>
<listitem><para>4. Installer les binaires</para>
<para>$ <emphasis>make install</emphasis></para>
<para>Cette étape peut nécessiter des droits d'administrateur.</para>
</listitem>
</itemizedlist>
<para><emphasis role="bold">Note</emphasis>: pensez à ajouter le répertoire
d'installation dans le $PATH</para>
</section> <!-- End compilation des sources -->

<section>
<title>Vérifier l'installation</title>
<para>
En supposant que la variable d'environnement INSTALL_PREFIX pointe à la racine
du repertoire d'installation (/opt/vishnu dans notre exemple), vous devez avoir les
programmes suivants en fonction des modules installés:
<itemizedlist>
<listitem>
<para>
$INSTALL_PREFIX/sbin/dispatcher : binaire du Dispatcher
</para>
</listitem>
<listitem>
<para>
$INSTALL_PREFIX/sbin/umssed : binaire du SeD UMS
</para>
</listitem>
<listitem>
<para>
$INSTALL_PREFIX/sbin/fmssed : binaire du SeD FMS
</para>
</listitem>
<listitem>
<para>
$INSTALL_PREFIX/sbin/tmssed : binaire du SeD TMS
</para>
</listitem>
<listitem>
<para>
$INSTALL_PREFIX/sbin/imssed : binaire du SeD IMS
</para>
</listitem>
<listitem>
<para>
$INSTALL_PREFIX/bin : contient les clients ligne de commande dont les noms sont
préfixés par <emphasis>vishnu_*</emphasis>.
</para>
<para>
Ex. vishnu_connect est le client ligne de commande pour se connecter à VISHNU.
</para>
</listitem>
<listitem>
<para>
$INSTALL_PREFIX/lib : contient les librairies dynamiques nommées sous la
forme <emphasis>libvishnu*</emphasis>.
</para>
</listitem>
<listitem>
<para>
$INSTALL_PREFIX/share : contient les pages de manuel pour les différents
programmes ligne de commande.
</para>
</listitem>
<listitem>
<para>
$INSTALL_PREFIX/etc : contient des exemples de fichiers de configuration.
</para>
</listitem>
</itemizedlist>
</para>
</section>

</chapter> <!-- End compilation -->
<chapter>
<title>Configuration de la base de données</title>
<para>Les fichiers de configuration de la base de données sont disponibles dans
le répertoire core/database du package d'installation VISHNU. Seules des bases
de données PostgreSQL ou MySQL sont actuellement supportées. Une seule base de
données est nécessaire et suffisante pour l'ensemble des composants d'une
infrastructure VISHNU (UMS, TMS, IMS et IMS).
</para>


<section>
<title>Utiliser une base de données MySQL</title>
<para>Nous supposons ici que vous avez déjà une installation de MySQL opérationnelle.
Si ce n'est pas le cas, référez-vous à la documentation officielle pour procéder à
l'installation.
</para>
<para>Vous devez également disposer des droits d'administration sur cette
installation (connexion à MySQL en tant l'utilisateur 'root').</para>
<para>Vous aurez besoin des scripts <emphasis>mysql_create.sql</emphasis>
et <emphasis>database_init.sql</emphasis> disponibles dans le dossier
<emphasis>./core/database</emphasis> de l'arborescence des sources.
Le premier script (<emphasis>mysql_create.sql</emphasis>) sert à créer
les tables de la base de données tandis que le second sert à initialiser
les données de la base.
</para>
<para>Pour la création de la base de données VISHNU, suivez les étapes suivantes :
<itemizedlist>
<listitem>
<para>Se connecter au serveur MySQL en tant que root :</para>
<para>$ <emphasis>mysql -h mysql@server- -u root -p </emphasis> # replacer mysql@server par l'adresse de votre serveur MySQL</para>
</listitem>
<listitem>
<para>Créer la base de données Vishnu</para>
<para>$ <emphasis>create database vishnu ; </emphasis></para>
</listitem>
<listitem>
<para>Se connecter sur la base de données</para>
<para>$ <emphasis>use vishnu ; </emphasis></para>
</listitem>
<listitem>
<para>Créer les tables</para>
<para>$ <emphasis>source /path/to/mysql_create.sql</emphasis></para>
</listitem>
<listitem>
<para>Initialiser la base de données</para>
<para>$ <emphasis>source /path/to/database_init.sql</emphasis></para>
</listitem>
</itemizedlist>
</para>
</section>

<section>
<title>Utiliser une base de données PostGreSQL</title>
<para>Nous supposons également que vous avez déjà une installation de PostGreSQL
opérationnelle. Si ce n'est pas le cas, référez-vous à la documentation officielle pour
procéder à l'installation.
</para>

<para>Vous devez également disposer des droits d'administration sur cette installation
(accès en tant qu'utilisateur système 'postgres').
</para>
<para>Pour une nouvelle installation de la base de données, les scripts
<emphasis>postgre_create.sql</emphasis> et <emphasis>database_init.sql</emphasis>
doivent respectivement être utilisés pour créer et initialiser la base de données.
</para>
<para>Pour créer et initialiser la base de données, exécuter les étapes
suivantes à partir de votre serveur PostGreSQL :
<itemizedlist>
<listitem>
<para>Se connecter en tant que l'utilisateur 'postgres' (root):</para>
<para>$ <emphasis>su postgres</emphasis></para>
</listitem>
<listitem>
<para>Créer la base de données vishnu</para>
<para>$ <emphasis>createdb -h localhost vishnu ; </emphasis></para>
</listitem>
<listitem>
<para>Se connecter à la base de données</para>
<para>$ <emphasis>psql -h localhost vishnu ; </emphasis></para>
</listitem>
<listitem>
<para>Créer le schéma de la base de données</para>
<para>$ <emphasis>\i /path/to/postgre_create.sql </emphasis></para>
</listitem>
<listitem>
<para>Initialiser la base de données</para>
<para>$ <emphasis>\i /path/to/database_init.sql</emphasis></para>
</listitem>
</itemizedlist>
</para>
</section>

<section>
<title>Bases de données distantes et Parefeu</title>
<para>
VISHNU repose sur une base de données. Les serveurs de VISHNU ont besoin de
s'y connecter pour fonctionner. Lorsqu'il n'y a aucune restriction sur les
ports accessibles entre différentes machines (cas fréquent dans un réseau
local), il n'y a généralement pas de problème pour se connecter à une base
de données distante en spécifiant correctement le databaseHost dans les
fichiers de configuration des éléments de VISHNU.
Dans le cas où il y a des restrictions sur les ports ouverts, ou dans le cas
de réseaux complexes avec du NAT par exemple, il est souvent plus facile de
passer par des tunnels ssh pour encapsuler les connexions vers la base de
données.
</para>
<para>
Supposons par exemple que la base de données soit sur une machine A et que le SeD VISHNU se trouve sur une machine B. Supposons aussi que le port d'écoute de la base de données est 3306.
Ainsi, selon la machine à partir de laquelle le tunnel est crée, nous pouvons avoir deux cas de figure.
</para>
<itemizedlist>
<listitem>
<para>
Si le tunnel est ouvert depuis la machine A vers la machine B, on parlera de tunnel "reverse". A partir de la machine A, il suffit s'exécuter une commande de la forme :
"reverse") :
</para>
<para>
ssh -t -t -R 3306:localhost:3306 user@B
</para>
</listitem>
<listitem>
<para>
Si le tunnel est ouvert depuis la machine B vers la machine A, on parlera de tunnel "forward". A partir de la machine B, il suffit s'exécuter une commande de la forme :
</para>
<para>
ssh -t -t -L 3306:localhost:3306 user@A
</para>
</listitem>
</itemizedlist>
<para>Pour tester que le tunnel fonctionne, placez-vous sur la machine B et connectez-vous à MySQL :
</para>
<programlisting>
mysql -u vishnu_user -h 127.0.0.1 -p
</programlisting>
<para>
Après avoir tapé le mot de passe, vous devriez vous retrouver connecté
sur la base de données sur la machine A.

Il ne vous reste plus qu'à configurer le fichier de configuration de
l'élément VISHNU avec les éléments suivants (à adapter en fonction de votre
configuration) :
</para>
<programlisting>
databaseType=mysql
databaseHost=127.0.0.1
databaseName=vishnu
databaseUserName=vishnu_user
databaseUserPassword=vishnu_user
databaseConnectionsNb=5
</programlisting>

<para>
Attention : si vous utilisez localhost comme nom de machine pour vous connecter
à la base de données, vous risquez de rencontrer des problèmes si mysql est installé
sur B. En effet, mysql tente de se connecter en utilisant une socket linux
(généralement /var/run/mysqld/mysqld.sock), au lieu de tenter de se connecter
à une machine distante. Utilisez bien 127.0.0.1 pour databaseHost.
</para>
</section>

<section>
<title>Utilisation de LDAP</title>
<para>Nous supposons que vous avez déjà une installation de LDAP opérationnelle.
Si ce n'est pas le cas, référer vous à la documentation officielle pour procéder à
l'installation. Vous pouvez également installer ces dépendances à partir du
gestionnaire de paquets de votre système. Sur les systèmes basés sur Debian
par exemple, vous devez installer les paquets suivants: <emphasis>slapd,
libldap-2.4-2, libldap2-dev</emphasis> et <emphasis>ldap-utils</emphasis></para>
<para>Pour pouvoir utiliser l'authentification avec LDAP, le flag de compilation
ENABLE_LDAP doit être activé à la compilation. Une fois VISHNU compilé,
une option de configuration du serveur UMS doit être mise dans le fichier de
configuration. Cette option est nommée 'authenticationType' et peut actuellement
supporter 4 valeurs :
<itemizedlist>
<listitem>
<para>
UMS : Authentifie uniquement en utilisant la base de données
</para>
</listitem>
<listitem>
<para>
LDAPUMS : Pour chaque couple (nom d'utilisateur, mot de passe), essaye
d'authentifier avec LDAP en premier puis avec UMS
</para>
</listitem>
<listitem>
<para>
UMSLDAP : Pour chaque couple (nom d'utilisateur, mot de passe), essaye
d'authentifier avec UMS en premier puis avec LDAP
</para>
</listitem>
<listitem>
<para>
LDAP : Authentifie uniquement en utilisant LDAP
</para>
</listitem>
</itemizedlist>
</para>
</section>
</chapter>

<chapter>
<title>Configuration et démarrage des services</title>
<section>
<title>Résumé des programmes serveurs</title>
<para>
Selon les modules sélectionnés, les binaires suivants doivent être disponibles sur votre système après l'installation:
<itemizedlist>
<listitem>
<para>
Dispatcher: $INSTALL_PREFIX/sbin/dispatcher
</para>
</listitem>
<listitem>
<para>
SeD UMS: $INSTALL_PREFIX/sbin/umssed
</para>
</listitem>
<listitem>
<para>
SeD FMS: $INSTALL_PREFIX/sbin/fmssed
</para>
</listitem>
<listitem>
<para>
SeD TMS : $INSTALL_PREFIX/sbin/tmssed
</para>
</listitem>
<listitem>
<para>
SeD IMS : $INSTALL_PREFIX/sbin/imssed
</para>
</listitem>
</itemizedlist>
</para>
</section>

<section>
<title>Configuration des SeDs</title>
<para>Cette section décrit les clés de configuration des différents composants de VISHNU.
Pour une première configuration, vous pouvez vous inspirer du fichier d'exemple
<emphasis>vishnu-sample.cfg</emphasis> situé dans le dossier $INSTALL_PREFIX/etc et également décrit ci-dessous. 
Tout texte après un dièse '#' est un commentaire.</para>
<programlisting>
<![CDATA[
# This is a commented sample configuration file for VISHNU
# Copyright (c) SysFera SA
# Last update: 16/01/2013
#

# Legends:
#  (M): Indicates that a key is mandatory for all components and MUST not be empty.
#  (M<List of Components>): Indicates a key is specific and mandatory for the
#                           listed components.
#  (O): Indicates that a key is optional.
#  (O)<List of Components>: Indicates that a key is optional only for the
#                           listed components.
#  (OS<List of Components>): Indicates a key is optional and specific to
#                             the listed components.
#   E.g. (OS<TMS>) means that a key is optional and specific to the Task
#   Management System (TMS) module.
#
# Definitions
# FMS: File Management System
# IMS: Information Management System
# TMS: Task Management System
# UMS: User Management System
# FQDN: Full Qualified Domain Name


###############################################################################
#               Common Parameters                                             #
###############################################################################
# vishnuId (M<FMS,IMS,TMS,UMS>): Sets the identifier of the VISHNU instance
#
vishnuId=1

# databaseType (M<FMS,IMS,TMS,UMS>): Defines the type of the database.
# Possible values are 'mysql' or 'postgresql'
#
databaseType=mysql

# databaseHost (M<FMS,IMS,TMS,UMS>): Defines the IP address or the FQDN of the
# database server.
# Here we assume that the database and VISHNU are hosted on the same server
#
databaseHost=localhost

# databaseName (M<FMS,IMS,TMS,UMS>): Sets the name of the database instance
#
databaseName=vishnu

# databaseUserName (M<FMS,IMS,TMS,UMS>): Sets the login name for authenticating
# against the database
#
databaseUserName=vishnu

# databaseUserPassword (M<FMS,IMS,TMS,UMS>): Sets the password associated to
# the database user
#
databaseUserPassword=vishnu


###############################################################################
#                Dispatcher Related Parameters                                #
###############################################################################


# disp_uriAddr (M<Dispatcher,Client>):
#  * For Dispatcher this corresponds to the address on which it'll listen on
#    for client requests
#  * For Clients this indicates the address for connecting to the Dispacther
#
disp_uriAddr=tcp://127.0.0.1:5560

# disp_uriSubs (M<Dispatcher>|O<IMS|TMS|FMS|UMS>):
# ** For the Dispatcher, it indicates the address to listen on for SeD subscription
# ** For SeD (FMS, IMS, TMS, UMS), this corresponds to the address from which
#    the module will register itself to the Dispatcher
#
disp_uriSubs=tcp://127.0.0.1:5561

# disp_nbthread (OS<Dispatcher>):
# Sets the number of workers threads in the Dispatcher
#
# In a platform with a high number of concurrent request, increase
# the number of workers may be interesting for reducing response time.
# Conversely, if the number of concurrent requests is low, decrease the may
# preserve useless resource consumption.
#
disp_nbthread=5


###############################################################################
#                UMS Related Parameters                                       #
###############################################################################

# ums_uriAddr (M<UMS>|O<Dispatcher,Client>):
#   * For UMS, this sets the address and the port on which the UMS SeD
#     will listen on
#   * For Dispactcher and clients it indicates address(es) for connecting
#     to UMS SeDs.
#     For Dispatcher this should correspond to a list of colon-seperated pair
#     in the form of: ums_uriAddr=uri_umssed1 sed1_name;uri_umssed2 sed2_name;...
#     uri_umssed<i> correspond to valid URIs. sed<i>_name set the
#     names associated to the SeDs
#     E.g. ums_uriAddr=tcp://127.0.0.1:5562 localsed;tcp://192.168.1.1:5562 lansed
#
ums_uriAddr=tcp://127.0.0.1:5562

# sendmailScriptPath (M<UMS>): Sets the path to the script for sending emails
#
sendmailScriptPath=/opt/software/GIT/vishnu_1/core/src/utils/sendmail.py

# authenticationType (M<UMS>): Defines the underlying authentication mode
# VISHNU supports four modes of authentication:
#  * UMS: Authentication against the built-in user management system (default).
#  * LDAP: Authentication against an LDAP directory
#  * UMSLDAP: Use both modes, looking first in the native authentication database
#  * LDAPUMS: Use both modes, looking first in the LDAP directory
# If not set, UMS mode will be selected.
#
#authenticationType=UMS


###############################################################################
#                FMS Specfic Parameters                                       #
###############################################################################

# fms_uriAddr (M<FMS>|O<Dispatcher,Client>):
#   * For FMS, this sets the address and the port on which the FMS SeD
#     will listen on
#   * For Dispactcher and clients it indicates address(es) for connecting
#     to FMS SeDs.
#     For Dispatcher this should correspond to a list of colon-seperated pair
#     in the form of: fms_uriAddr=uri_fmssed1 sed1_name;uri_fmssed2 sed2_name;...
#     uri_fmssed<i> correspond to valid URIs. sed<i>_name set the
#     names associated to the SeDs
#     E.g. fms_uriAddr=tcp://127.0.0.1:5563 localsed;tcp://192.168.1.1:5563 lansed
#
fms_uriAddr=tcp://127.0.0.1:5563


###############################################################################
#                IMS Related Parameters                                       #
###############################################################################

# ims_uriAddr (M<IMS>|O<Dispatcher,Client>):
#   * For IMS, this sets the address and the port on which the IMS SeD
#     will listen on
#   * For Dispactcher and clients it indicates address(es) for connecting
#     to IMS SeDs.
#     For Dispatcher this should correspond to a list of colon-seperated pair
#     in the form of: ims_uriAddr=uri_imssed1 sed1_name;uri_imssed2 sed2_name;...
#     uri_imssed<i> should correspond to valid URIs. sed<i>_name set the
#     names associated to the SeDs.
#     E.g. ims_uriAddr=tcp://127.0.0.1:5564 localsed;tcp://192.168.1.1:5564 lansed
#
ims_uriAddr=tcp://127.0.0.1:5564


###############################################################################
#                TMS Related Parameters                                       #
###############################################################################
# tms_uriAddr (M<TMS>|O<Dispatcher,Client>):
#   * For TMS, this sets the address and the port on which the TMS SeD
#     will listen on
#   * For Dispactcher and clients it indicates address(es) for connecting
#     to TMS SeDs.
#     For Dispatcher this should correspond to a list of colon-seperated pair
#     in the form of: ims_uriAddr=uri_tmssed1 sed1_name;uri_tmssed2 sed2_name;...
#     uri_tmssed<i> correspond to valid  URIs. sed<i>_name set the
#     names associated to the SeDs.
#     E.g. tms_uriAddr=tcp://127.0.0.1:5565 localsed;tcp://192.168.1.1:5565 lansed
#
tms_uriAddr=tcp://127.0.0.1:5565

# batchSchedulerType (M<TMS>): Defines the type of the batch scheduler TMS
# will handle.
# VISHNU supports TORQUE, LOADLEVELER, SLURM, LSF, SGE and PBS
batchSchedulerType=SLURM

# intervalMonitor (M<TMS>): In seconds, this key defines the interval after
# which the jobs are monitored
#
intervalMonitor=30

# defaultBatchConfig (OS<TMS>): Sets the path to the default batch configuration
# file.
#
#defaultBatchConfig=$HOME/defaultbatch.cfg


###############################################################################
#                Other Parameters                                             #
###############################################################################

# vishnuMachineId (M<FMS,IMS,TMS>|O<UMS>): Optional for UMS and mandatory for FMS,
# IMS and TMS, this key corresponds to the identifier of the machine in VISHNU
# environment.
# When set, it MUST correspond to valid machine identifier.
#
vishnuMachineId=machine_1

# timeout (M<Dispatcher>|O<FMS,IMS,TMS,UMS>): In seconds, this defines the
# duration afer which a request is considered as expired.
#
timeout=120

#uriSupervisor (O<FMS,IMS,TMS,UMS>): Specifies the address of Supervisord
uriSupervisor=http://127.0.0.1:9001
]]>
</programlisting>
<section>
<title>Configuration de Supervisod</title>
<para>
Nous vous recommandons de lancer les SeDs via Supervisord. C'est un moniteur d'exécution qui contrôle l'exécution des services 
en offrant des fonctionnalités de resilience. En effet, lorsqu'un service tombe de manière inattendue, il se charge de le redemarrer 
de manière transparente.
</para>
<para>L'exemple ci-dessous décrit la configuration de Supervisord. Il est inspiré du fichier d'exemple <emphasis>supervisord-sample.cfg</emphasis> situé dans le dossier $INSTALL_PREFIX/etc. 
Vous pouvez vous en inspirer pour l'adapter à votre installation. Tout texte après un point-virgule ';' est un commentaire.</para>
<programlisting>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;; PARAMETRES LIES A LA PRISE EN CHARGE DES COMPOSANTS DE VISHNU ;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Attention: il faut bien respecter les nommages 'umssed', 'imssed',
; 'tmssed', 'fmssed'. Sinon ils ne seront pas bien pris en charge

; Définir le SeD UMS comme un processus à surveiller
; Son alias est umssed
; command indique la commande à exécuter. A modifier selon votre installation
[program:umssed]
command=umssed ~/conf/ums_config.cfg ; Commande comme on ferait dans un terminal

; Définir le SeD FMS comme un processus à surveiller
; Son alias est fmssed
; command indique la commande à exécuter. A modifier selon votre installation
[program:fmssed]
command=fmssed ~/conf/fms_config.cfg

; Définir le SeD IMS comme un processus à surveiller
; Son alias est imssed
; command indique la commande à exécuter. A modifier selon votre installation
[program:imssed]
command=imssed ~/conf/ims_config.cfg

; Définir le SeD TMS comme un processus à surveiller
; Son alias est tmssed
; command indique la commande à exécuter. A modifier selon votre installation
[program:tmssed]
command=tmssed ~/conf/tms_config.cfg

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; PARAMETRES SPECIFIQUES A SUPERVISORD ;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Définir l'URL de connexion à Supervisord
[supervisorctl]
serverurl=http://127.0.0.1:9001

; inet (TCP) server disabled by default
; ip_address:port specifier, *:port for all if
[inet_http_server]
port=127.0.0.1:9001
</programlisting>
</section>
<section>
<title>Notes spécifiques pour l'intégration TMS-DELTACLOUD</title>
<para>
TMS est une composante clé d'une architecture VISHNU. Grâce à son architecture souple, il s'intègre dans différents types d'environnements de calcul. 
Des environnements traditionnels reposant sur des batch schedulers classiques comme LoadLeveler et SLURM, il a été étendu pour s'interfacer avec
les gestionnaires de ressources virtuelles (aussi appelés gestionnaires de cloud) tels qu'OpenStack et OpenNebula. Basé sur Delatcloud et actuellement en version beta, cette extension a été testée avec OpenStack et OpenNebula.
</para>
<para>
L'intégration avec les gestionnaires de ressources virtuelles nécessite un mode de fonctionnement interne relativement différent de ce 
qui se passe avec les batch schedulers traditionnels. En effet, étant donné que ces gestionnaires ne gèrent pas les tâches, VISHNU fournit 
des fonctionnalités supplémentaires pour assurer cette gestion. 
Conceptuellement, chaque tâche est exécutée au sein d'une machine virtuelle qui est automatiquement instanciée à cet effet. 
Cette machine virtuelle est également automatiquement détruite à la fin de tâche. Par ailleurs, pour simplifier la gestion des données d'entrée et de sortie, VISHNU permet de définir un système de fichiers NFS qui est monté automatiquement dans l'arborescence de la machine virtuelle 
au démarrage. De manière résumée, pour gérer le cycle de vie des tâches, VISHNU assure entre autres :
<itemizedlist>
<listitem>
<para>
L'authentifiation sur le gestionnaire de ressources virtuelles.
</para>
</listitem>
<listitem>
<para>
L'instanciation et le démarrage des machines virtuelles.
</para>
</listitem>
<listitem>
<para>
Le démarrage des scripts au sein des machines virtuelles. 
</para>
</listitem>
<listitem>
<para>
La supervision des scripts et des machines virtuelles
</para>
</listitem>
<listitem>
<para>
La suspension des machines virtuelles lorsque les tâches qu'elles exécutent sont terminées.
</para>
</listitem>
</itemizedlist>
</para>
<para>
La prise en charge de ces fonctionnalités nécessite un ensemble de paramètres de configuration supplémentaires. 
Ces paramètres sont singuliers pour la gestion de ressources virtuelles et ne s'appliquant pas aux batch schedulers traditionnels. 
C'est pour cela qu'il sont définis en dehors du fichier de configuration principal pour mieux gérer leur caractère optionnel tout 
en simplifiant la configuration de l'ensemble. 
Deux étapes simples sont nécessaires pour configurer l'intégration avec Deltacloud. 
Dans un premier temps, vous devez spécifier dans le fichier de configuration principal que le batch scheduler 
sous-jacent est Deltacloud (<emphasis>batchSchedulerType=DELTACLOUD</emphasis>). Et, ensuite, 
définir les paramètres spécifiques pour la gestion de ressources virtuelles.
</para>
<para>
Ces paramètres, listés ci-dessous, sont définis au niveau global par l'administrateur et peuvent etre surpassés par des options 
spécifiques définies par l'utilisateur lors de la soumission d'une tâche. Voir le manuel utilisateur pour plus de détails:
<itemizedlist>
<listitem>
<para>
Les variables d'environnements.
</para>
<para>
Définies sur la machine où est lancé le SeD TMS, ces variables sont :
<itemizedlist>
<listitem>
<para>
VISHNU_CLOUD_ENDPOINT : Définit l'url d'accès à l'API Delatcloud. 
</para>
<para>
Ex. <emphasis>VISHNU_CLOUD_ENDPOINT=http://192.168.1.1:3001/api</emphasis> indique que l'API Delatcloud est accessible via le port 3001 de la machine ayant l'adresse IP 192.168.1.1, à noter le contexte /api qui est obligatoire. Ceci suppose que sur cette machine <emphasis>deltacloudd</emphasis> a été démarrée pour écouter sur ce port. 
</para>
</listitem>
<listitem>
<para>
VISHNU_CLOUD_USER : Définit la chaine de connexion au gestionnaire de ressources virtuelles. 
En général cela correspond au login d'un utilisateur sur le gestionnaire de cloud. Cas particulier :
pour OpenStack, ceci doit être une chaine sous la forme <emphasis>user+tenant</emphasis>. Où <emphasis>user</emphasis> et <emphasis>tenant</emphasis> désignent respectivement le login de l'utilisateur et le nom du tenant auquel il appartient.
</para>
<para>
Ex. <emphasis>VISHNU_CLOUD_USER=bob+sysfera</emphasis> définit la chaine de connexion pour l'utilisateur bob du tenant sysfera.
</para>
</listitem>
<listitem>
<para>
VISHNU_CLOUD_USER_PASSWORD : Définit le mot de passe à associer à la chaine de connexion. 
</para>
</listitem>
<listitem>
<para>
VISHNU_CLOUD_VM_IMAGE : Définit l'identifiant de l'image à utiliser pour instancier les machines virtuelles. 
Cette valeur doit être valide et correspondre à une image que l'utilisateur défini par VISHNU_CLOUD_USER a le droit d'instancier.
</para>
</listitem>
<listitem>
<para>
VISHNU_CLOUD_VM_USER : Définit l'identifiant de l'utilisateur sous lequel les tâches seront exécutées au sein des machines virtuelles. Cet identifiant n'est pas crée par VISHNU, il doit donc correspondre à un identifiant réel au sein de la machine virtuelle. 
</para>
</listitem>
<listitem>
<para>
VISHNU_CLOUD_VM_USER_KEY : Spécifique à OpenStack, ce paramètre définit le nom de la clé SSH à déployer dans les machines virtuelles. La valeur doit correspondre à une clé enregistrée dans le gestionnaire de cloud. Pour OpenNebula, la copie de clé SSH est réalisée via le mécanisme de contextualisation. Voir les fichiers d'exemple disponibles dans le repertoire <literal>contrib</literal> pour plus de détails.
</para>
</listitem>
<listitem>
<para>
VISHNU_CLOUD_DEFAULT_FLAVOR : Définit la flavor par défaut des machines virtuelles. Idem, cette valeur doit correspondre à une
flavor définie dans le gestionnaire de cloud. 
</para>
</listitem>
<listitem>
<para>
VISHNU_CLOUD_NFS_SERVER : Définit l'adresse du serveur NFS sur lequel sont stockées les données ou des applications partagées par des machines virtuelles. Ce paramètre peut-être défini : (i) soit via le fichier <literal>.vishnurc</literal>; (ii) soit via les metadonnées (données de contextualisation) de la machine virtuelle. Cette seconde approche est recommendée si votre infrastructure de cloud supporte la contextualisation des machines virtuelles, de type cloud-init ou de type OpenNebula. Vous pouvez consulter les exemples de template et de script de contextualisation disponibles dans le repertoire <literal>contrib</literal> pour plus de détails.
</para>
</listitem>
<listitem>
<para>
VISHNU_CLOUD_NFS_MOUNT_POINT : Désigne le point de montage sur le serveur NFS. Utilisé conjointement avec le paramètre VISHNU_CLOUD_NFS_SERVER, ce paramètre peut également être défini soit via le fichier <literal>.vishnurc</literal> ou via les métadonnées de contextualisation.
</para>
</listitem>
</itemizedlist>
</para>
</listitem>
<listitem>
<para>
Le fichier <emphasis>.vishnurc</emphasis>
</para>
<para>
Si définit dans le dossier personnel de l'utilisateur sous lequel s'exécute le SeD TMS, ce fichier est lu à chaque soumission de tâche pour surpasser les valeurs des paramètres définies via les variables d'environnement. Dans ce fichier, les paramètres sont définis sous-forme <emphasis>clé=valeur</emphasis>, avec une entrée par ligne. Voir l'exemple ci-dessous. Les lignes commençant par 
dièse '#' sont des commentaires.
</para>
<![CDATA[
# Ce fichier est un example de .vishnurc
# Cette ligne, la précédente et la suivante sont des commentaires car commençant par '#'
#
VISHNU_CLOUD_ENDPOINT=http://192.168.1.122:3001/api
VISHNU_CLOUD_USER=mockuser
VISHNU_CLOUD_USER_PASSWORD=mockpassword
VISHNU_CLOUD_TENANT=sysfera
VISHNU_CLOUD_VM_IMAGE=0dfb0b70-0262-48f1-baf4-63f63ee018df
VISHNU_CLOUD_VM_USER=root
VISHNU_CLOUD_VM_USER_KEY=root-key
VISHNU_CLOUD_DEFAULT_FLAVOR=1
VISHNU_CLOUD_NFS_SERVER=172.17.6.6
VISHNU_CLOUD_NFS_MOUNT_POINT=/tmp/cloud
]]>
</listitem>
</itemizedlist>
</para>
</section>
</section>
<section>
<title>Déploiement dans un même sous-réseau</title>
<para>Dans cette section nous supposons que tous les composants vont être déployés sur une même machine nommée
<emphasis role="bold">prefrontale</emphasis>.
</para>
<para><emphasis role="bold">NOTES :</emphasis> Il existe un bug connu sur debian (entre autre) avec boost file system, utilisé par VISHNU.
Le rapport de bug est ici et le bug est actuellement ouvert: https://svn.boost.org/trac/boost/ticket/4688.
Si lors du lancement d'un SeD, le message d'erreur suivant apparait : std::runtime_error:
locale::facet::_S_create_c_locale name not valid,
faire un "export LANG=C" et cela devrait régler le problème.
</para>
<para>Une fois la configuration des différents composants terminée, suivez
attentivement les étapes suivantes pour les déployer:</para>
<orderedlist>
<listitem>
<para>Vérifier que la base de données (PostGreSQL ou MySQL) a été bien configurée et initialisée comme
décrit précédemment. De plus, vérifier que vous pouvez vous connecter à la base de données depuis les différents
serveurs où sont installés les modules de VISHNU.</para>
</listitem>
<listitem>
<para>
Sur une machine Torque, lancer le serveur (pbs_serv), le scheduler (pbs_sched) et l'ordonnanceur
(pbs_mom).
</para>
</listitem>
<listitem>
<para>
Sur une machine SLURM, lancer les serveurs <emphasis>slurmd, slurmctld</emphasis> et <emphasis>slurmdbd</emphasis>.
</para>
</listitem>
<listitem>
<para>
Sur une machine LSF, lancer les exécutables <emphasis/>hostsetup <emphasis>lsfstartup</emphasis>.
</para>
</listitem>
<listitem>
<para>
Sur une machine Grid Engine, lancer les exécutables <emphasis>sge_qmaster </emphasis> et <emphasis>sge_execd</emphasis>.
</para>
</listitem>
<listitem>
<para>
Optionnel: Sur une machine lancer le dispatcher, le fichier de
configuration 'config' doit être à la fin et est optionnel.</para>
<para>$ <emphasis>dispatcher dispatcher_config.cfg</emphasis></para>
<para>
Dans cette commande, on demande au dispatcher de démarrer en
utilisant les serveurs définis dans le fichier 'config'. Si le
fichier de configuration n'est pas fourni, des options par défaut sont utilisées. Les différents options de configurations et leur valeur par défaut sont décrites deux sections plus loin.
</para>
</listitem>
<listitem>
<para>Sur chaque machine serveur, lancer supervisord avec son fichier de configuration 'config' correspondant. Le fichier de configuration de supervisord contient le démarrage de chaque serveur vishnu sur la machine en question.</para>
<para>$ <emphasis>supervisord -c config</emphasis></para>
</listitem>
<listitem>
<para>
Les modules de VISHNU sont prêts à être utilisés. Pour ce faire, un client doit se connecter et soumettre des requêtes à VISHNU au moyen des commandes UMS, TMS, FMS et IMS (voir le manuel de l'utilisateur VISHNU pour plus d'informations sur les commandes utilisateurs disponibles).
</para>
</listitem>
</orderedlist>
</section>
<section>
<title>Le cas multi-réseaux</title>
<para>
Le cas multi-réseaux ne change pas du cas précédent, les étapes sont toutes les mêmes. Le seul ajout à faire est d'ajouter des tunnels SSH entre les machines serveurs et la machine ou se trouve la base de données s'il n'y a pas d'accès direct sur le port correspondant au port de la base de données, et un second tunnel pour l'enregistrement des serveurs sur le dispatcher. Par la suite, il est conseillé d'utiliser le dispatcher pour que le client n'ait plus qu'à se connecter au dispatcher pour réaliser ses requêtes (le dispatcher jouant alors un rôle de proxy entre le client et les réseaux).</para>
<para>
Les tunnels SSH sont faits avec une commande similaire à l'une des suivantes:
<itemizedlist>
<listitem>
<para>
ssh -fN -L 8889:localhost:8889 machine_distance
</para>
<para>
Etablir un tunnel entre la machine locale et la machine distante au travers du port 8889.
</para>
</listitem>
<listitem>
<para>
            </para>
<para>
Etablir un reverse tunnel entre la machine locale et la machine distante au travers du port 8889
ssh -R -fN 8889:localhost:8889 machine_distante
</para>
</listitem>
</itemizedlist>
</para>
</section>

<section>
<title>Configuration de l'envoi des emails par VISHNU</title>
<para>Le processus UMS SeD utilise le fichier 'sendmail.py' (fourni dans l'installation VISHNU, dans le sous-répertoire sbin/)
pour envoyer des emails aux utilisateurs lors de certaines opérations. Ce fichier peut être modifié par l'administrateur afin
de s'adapter à la méthode d'envoi d'email propre au serveur sur lequel est installé le SeD. Par défaut, la configuration
fournie se connecte sur le serveur SMTP de 'localhost' sur le port 25, sans authentification.</para>
<para>Les paramètres suivants peuvent être configurés dans le script sendmail.py :</para>
<informaltable>
<tgroup cols="2">
<colspec colwidth="2cm"/>
<colspec colwidth="15cm"/>
<thead>
<row>
<entry>Option</entry>
<entry>Ligne du script sendmail.py à modifier</entry>
</row>
</thead>
<tbody>
<row>
<entry><para>login</para></entry>
<entry><programlisting>parser.add_option("--login", dest="login", help="", default="[login_utilisateur]")</programlisting></entry>
</row>
<row>
<entry><para>password</para></entry>
<entry><programlisting>parser.add_option("--password", dest="password", help="smtp password", default="[password_utilisateur]")</programlisting></entry>
</row>
<row>
<entry><para>hostname</para></entry>
<entry><programlisting>parser.add_option("--hostname", dest="host", help="smtp host", default="[nom_serveur_SMTP]")</programlisting></entry>
</row>
<row>
<entry><para>port</para></entry>
<entry><programlisting>parser.add_option("--port", dest="port", help="smtp port [default: 25]", type=int, default="[no_port]")</programlisting></entry>
</row>
<row>
<entry><para>SSL</para></entry>
<entry><programlisting>parser.add_option("--ssl", action="store_true", dest="use_ssl", help="enable ssl support [default: %default - default port: 587
]", default=True)</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section>
<title>Configuration des clés privées/publiques ssh requises pour FMS</title>
<para>
Toutes les commandes éxécutées par le SeD FMS sont lancées via ssh
sous le nom de l'utilisateur ayant émis la requête. Les services FMS
sont de deux types : il y a ceux qui n'impliquent qu'une machine
distante : Exemple getFilesInfo,listDir,etc.. et ceux qui impliquent au
moins deux machines distantes : machine source et destination pour les transferts de fichiers.
<itemizedlist>
<listitem>
<para>Dans le premier cas le SeD se connecte sur la machine distante et
effectue la commande. Par conséquent la clé publique du SeD doit
être ajoutée au fichier authorized_keys ($HOME/.ssh/authorized_keys) de l'utilisateur de la machine distante
concernée.</para>
</listitem>
<listitem>
<para>Dans le second cas, deux connexions ssh sont nécessaires. Le SeD se connecte sur la machine source et
lance le transfert (seconde connexion) vers la machine destination. Par conséquent:
<itemizedlist>
<listitem>
<para>la clé publique du SeD doit être ajoutée au fichier authorized_key de la machine source pour
permettre la première connexion.
</para>
</listitem>
<listitem>
<para>La machine source doit pouvoir se connecter sur la machine destination par ssh, avec la clé privée enregistrée dans la base de VISHNU lors de l'ajout du compte (local account) liant la machine source à VISHNU. Par ailleurs si le mécanisme d'agent forwarding (de ssh) est activée entre ces différentes machines, il n'est alors plus nécessaire qu'il y ait un autre couple de clés entre la machine source et destination. </para>
</listitem>
</itemizedlist>
</para>
</listitem>
</itemizedlist>
En somme, il est alors obligatoire que la clé publique du SeD soit ajoutée à tous les comptes utilisateurs des machines impliquées
par les requêtes FMS. Toutes les clés protégées par des passphrases ne sont pas supportées.
</para>
</section>


<section>
<title>Configuration des clés privées/publiques ssh requises pour TMS</title>
<para>
Les commandes de soumission, d'annulation et de récupération des résultats de jobs éxécutées par le SeD TMS sont lancées via ssh
sous le nom de l'utilisateur ayant émis la requête. Pour pouvoir exécuter ces commandes correctement, la clé publique du compte dédié au SeD TMS doit
être ajoutée au fichier authorized_keys ($HOME/.ssh/authorized_keys) de l'utilisateur. Toutes les clés protégées par des passphrases ne
sont pas supportées.
</para>
</section>

<section>
<title>Test d'exécution d'un service depuis une machine client par shell</title>
<orderedlist>
<listitem>
<para>
Une fois que la plateforme a été installée, se mettre sur un poste client avec VISHNU d'installé. Se référer au document [VISHNU_USERMANUAL]
pour l'installation de la partie client.
</para>
</listitem>
<listitem>
<para>
Exporter la variable d'environnement VISHNU_CONFIG_FILE dans un script de configuration client. Se référer
au guide d'installation du client [VISHNU_USER_GUIDE] pour connaître le contenu d'un fichier client.
</para>
</listitem>
<listitem>
<para>Ouvrir une session VISHNU</para>
<para>$ <emphasis>vishnu_connect -u user</emphasis></para>
<para>Remplacer 'user' par un vrai identifiant utilisateur.
Par défaut, VISHNU est installé avec un utilisateur 'root' ayant tous les droits sur la plateforme (ID: 'root', Mot de passe: 'vishnu_user').
</para>
</listitem>
<listitem>
<para>
Entrer le mot de passe puis valider
</para>
</listitem>
<listitem>
<para>
Sur le client, un affichage doit signaler que le service a réussi. Dans le terminal ou le SeD UMS a été lancé et dans le terminal ou le MA tourne, selon le niveau de verbosité, plus ou moins d'informations, concernant le service effectué, doivent apparaitre. Le message affiché contient au moins une ligne similaire :
<emphasis role="bold">sessionId: root-2011-Jul-11-14:22:14.403491:86690</emphasis>, qui indique l'identifiant de la session ouverte.
</para>
</listitem>
<listitem>
<para>Fermer la session.</para>
<para>$ <emphasis>vishnu_close</emphasis> </para>
<para>Aucune erreur ne doit être remontée.</para>

</listitem>
</orderedlist>
</section>
<section>
<title>Les scripts de démarage automatique</title>
<para>Des scripts de démarage sont préparés pour pouvoir exécuter automatiquement les serveurs VISHNU.
Les scripts sont installés lors de l'installation des serveurs dans install/etc/ (ou dans /etc si c'est installé dans /usr).</para>
</section>
</chapter><!-- End lancement  -->

<chapter>
<title>Configuration avancées et sécurité</title>
<section>
<title>TMS en mode natif</title>
<para>
Après installation, il est possible d'utiliser les fonctionnalités de TMS sur une machine
ne possédant pas de batch scheduler. Ce mode de fonctionnement natif est appelé TMS Posix Shell. Le type de batch scheduler associé est 'POSIX'.
</para>
<para>
Lors de la compilation, ce module est activé automatiquement et indépendamment du batch scheduler sélectionné. Il est également possible de ne compiler que ce module en choississant 'POSIX' comme bacth scheduler lors de la compilation. Le flag dans le fichier de configuration du serveur TMS sera également POSIX. Il faut noter que lors de la compilation de VISHNU pour un batch scheduler classique, ce pseudo batch est automatiquement compilé, et l'utilisateur peut lors du submit explicitement demander à soumettre sur le batch posix en utilisant l'option -p. Sinon, c'est systématiquement le vrai batch scheduler auquel vishnu soumet. Cela implique que d'un point de vue système, vishnu a constamment 3 processus 'tmssed' dans le cas d'un batch scheduler classique, un premier qui est le serveur réalisant les services, et les 2 autres correspondent à des moniteurs utilisés par vishnu (pour interroger les batchs schedulers sous-jacents) pour avoir les données à jour associées aux jobs. De plus, afin de gérer les jobs utilisateurs et pouvoir les annuler, pour chaque utilisateur ayant un job, cet utilisateur aura un démon qui
tournera, pourra controller les jobs, et fournir des informations au moniteur au
travers d'une socket unix.
</para>
</section>

<section>
<title>Connexions en mode sécurisé</title>
<para>
Par défaut, les communications entre les clients VISHNU et les SeD, de même que les communications entre les SeD et la base de données sont non chiffrées. C'est-à-dire qu'elles transitent en clair sur le réseau. Ceci peut constituer un facteur de vulnérabilité. Afin d'améliorer la sécurité, VISHNU intègre depuis les versions ultérieures à la version 3.0.0, le support de chiffrement des communications (clients--SeDs, SeDs -- base de données). Ce chiffrement se base sur des certificats SSL, et repose sur la librairie OpenSSL <ulink url="http://www.openssl.org/">http://www.openssl.org/</ulink>. Vous pouvez consulter la documentation officielle pour plus d'information sur le chiffrement et les certificats <ulink url="http://www.openssl.org/docs/">http://www.openssl.org/docs/</ulink>.
</para>
<para>Non activé par défaut, vous devez explicitement activer le support SSL. Avant toute chose, vous devez <emphasis>disposer d'un certificat valide</emphasis>; vous pouvez utiliser un certificat signé par une autorité de certification ou un certificat autosigné (voir la documentation d'OpenSSL). Pour les plus pressés, le script <emphasis>create-ssl-cert.sh</emphasis> fourni avec VISHNU permet de créer rapidement des certificats autosignés. Avant de l'exécuter, vous devez l'éditez pour adapter le mot de passe du certificat, ainsi que les paramètres liés au nom du serveur pour lequel le certificat sera généré. 
</para>
<para>
Cela se fait à deux niveaux : au niveau des communications entre les SeDs et les clients et au niveau des communications avec les SeDs et la base de données. La prochaine section décrit comment activer le support SSL entre les SeD et les clients VISHNU, tandis que la section suivante décrira la configuration des connexions SSL entre les SeDs et la base de données.
</para>
</section>

<section>
<title>Activation du support SSL coté client et coté SeDs</title>
<para>
Dans un premier temps, vous devez avoir compilé VISHNU avec le support SSL. C'est normalement le cas par défaut. 
Ensuite, vous devez activer des clés de configuration appropriées selon que vous êtes du coté client ou coté SeDs :
</para>
<itemizedlist>
<listitem>
<para>
<literal>useSsl=1</literal> : de type entier et nécessaire aussi bien coté client que coté SeDs, cette clé doit avoir une valeur non nulle pour que le support SSL soit pris en compte. 
</para>
</listitem>
<listitem>
<para>
<literal>serverSslCertificate=/path/to/server/certificate</literal> : requis coté SeDs si l'option <literal>useSsl</literal> est activée, cette clé indique le chemin vers le certificat.
</para>
</listitem>
<listitem>
<para>
<literal>serverPrivateKey=/path/to/server/private/key</literal> : requis coté SeDs si l'option <literal>useSsl</literal> est activée, cette clé indique le chemin vers la clé privée du serveur.
</para>
</listitem>
<listitem>
<para>
<literal>sslCa=/path/to/cafile</literal> : optionnel coté client, cette clé indique le chemin vers le fichier contenant la liste des certificats de l'autorité de certification. Ce paramètre est notamment nécessaire pour un certificat autosigné. 
</para>
</listitem>
</itemizedlist>
<para>
L'activation ou la mise à jour d'un ou plusieurs de ces paramètres coté SeD nécessite le redémarrage des services. 
</para>
</section>



<section>
<title>Chiffrement des connexions à la base de données</title>
<para>
Aussi bien MySQl que PostGreSQL disposent d'un support natif pour l'utilisation de connexions SSL.
</para>
<section>
<title>Connexions SSL vers une base de données MySQL</title>
<para>
Les étapes de configuration décrites ci-dessous sont tirées de la documentation officielle de MySQL disponible à l'adresse suivante : <ulink url="http://dev.mysql.com/doc/refman/5.0/en/ssl-connections.html">http://dev.mysql.com/doc/refman/5.0/en/ssl-connections.html</ulink>. Les étapes de la procédure comportent :
<itemizedlist>
<listitem>
<para>
La vérification de la disponibilité du support SSL dans MySQL
</para>
</listitem>
<listitem>
<para>
La génération d'un certificat autosigné (optionnel)
</para>
</listitem>
<listitem>
<para>
L'activation du support SSL sur le serveur MySQL
</para>
</listitem>
<listitem>
<para>
Le test de connexion en SSL
</para>
</listitem>
</itemizedlist>
</para>


<section>
<title>Vérifier que MySQL a été compilé avec le support SSL</title>
<para>
Les binaires et les librairies client et serveur MySQL doivent avoir été compilés avec le support d'OpenSSL. Si ce n'est pas votre cas, vous devez réinstaller MySQL. Les étapes suivantes indiquent comment vérifier la disponibilité du support d'OpenSSL :
</para>
<itemizedlist>
<listitem>
<para>
Coté serveur, exécuter la commande suivante : <literal>$ mysqld --ssl --help</literal>
</para>
<para>
Si une erreur se produit, alors le binaire n'a pas été compilé avec le support SSL. 
</para>
</listitem>
<listitem>
<para>
Coté client, exécuter la commande suivante : <literal>$ mysql --ssl --help</literal>
</para>
<para>
Si une erreur se produit, alors le binaire n'a pas été compilé avec le support SSL. 
</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>Activer le support SSL dans le serveur MySQL</title>
<para>
Pour activer le support SSL sur le serveur MySQL, vous devez indiquer un certificat, la clé privé du serveur et les certificats de l'autorité de confiance (optionnel, mais requis si le certificat est autosigné). Le certificat peut être autosigné ou signé par une autotité de certification.
</para>
<para>
Une fois que vous disposez des différentes entités du certificat, la configuration de MySQL est assez simple :
</para>
<itemizedlist>
<listitem>
<para>
Editez le fichier de configuration de MySQL et indiquer les entités du certificat dans la section <emphasis>[mysqld]</emphasis>.
</para>
</listitem>
</itemizedlist>
<programlisting>
<![CDATA[
[mysqld]
ssl-ca=/opt/etc/sysfera/mysql-ssl/ca.pem
ssl-cert=/opt/etc/sysfera/mysql-ssl/server-cert.pem
ssl-key=/opt/etc/sysfera/mysql-ssl/server-key.pem
]]>
</programlisting>
<para>
Adapter les chemins en fonction de l'emplacement où vous avez stocké les différentes entités. Le paramètre <emphasis>ssl-ca</emphasis> doit pointer vers l'emplacement où vous avez stocké le fichier des certificats de l'autorité de confiance, <emphasis>ssl-cert</emphasis> doit pointer vers l'emplacement où vous avez stocké le certificat du serveur, tandis que le paramètre <emphasis>ssl-key</emphasis> doit pointer vers l'emplacement où vous avez stocké la clé privé du serveur.
</para>
<itemizedlist>
<listitem>
<para>
Redemarrer MySQL et vérifier que le support SSL a correctement été activé :
</para>
<itemizedlist>
<listitem>
<para>
Lancez un terminal et connectez-vous à MySQL en tant que super-utilisateur (root) : 
<literal>$ mysql -u root -p</literal>
</para>
</listitem>
<listitem>
<para>
Vérifier que le module SSL a été correctement chargé :
<literal>mysql&gt; show variables with '%ssl%'</literal>
</para>
<para>
Si le support SSL a été correctement activé, vous devez avoir une sortie comme celle affichée ci-dessous :
</para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<programlisting>
<![CDATA[
+---------------+--------------------------------------------+
| Variable_name | Value                                      |
+---------------+--------------------------------------------+
| have_ssl      | YES                                        |
| ssl_ca        | /opt/etc/sysfera/mysql-ssl/ca.pem          |
| ssl_cert      | /opt/etc/sysfera/mysql-ssl/server-cert.pem |
| ssl_key       | /opt/etc/sysfera/mysql-ssl/server-key.pem  |
+---------------+--------------------------------------------+
]]>
</programlisting>
<para>
Les valeurs des paramètres ssl_ca, ssl_cert et ssl_key doivent être conformes à votre configuration. 
</para>
</section>

<section>
<title>Tester la connexion en SSL à MySQL</title>
<para>
La connexion en SSL à une base de données MySQL nécessite que l'utilisateur MySQL ait dispose des privilèges spécifiques (<literal>REQUIRE SSL</literal>). Ce privilège est activé lors de l'attribution des rôles à l'utilisateur par le biais de la commande <literal>GRANT</literal>. 
</para>
<para>
Exemple : 
</para>
<programlisting>
<![CDATA[
mysql> GRANT SELECT ON vishnu.* 
       TO 'secure_user'@'127.0.0.1' 
       IDENTIFIED BY 'password' REQUIRE SSL;
]]>
</programlisting>
<para>
Cette commande indique que l'utilisateur 'secure_user' ne pourra se connecter à la base de donnée 'vishnu' qu'en mode SSL. Si l'option <literal>REQUIRE SSL</literal> est omise, seul le mode de connexion par défaut sera activé. Même si le support SSL a été activé au niveau du serveur. 
</para>
<para>
Pour se connecter à la base de données, il suffit d'exécuter la commande suivante. L'option <emphasis>--ssl-ca</emphasis> n'est requise que si le certificat a été autosigné ou a été généré par une autorité de certification non reconnue. 
</para>
<programlisting>
<![CDATA[
$ mysql -u secure_user -p \
  --ssl-ca=/opt/etc/sysfera/mysql-ssl/ca.pem
]]>
</programlisting>
</section>
</section>

<section>
<title>Connexion SSL vers une base de données PostGreSQL</title>
<para>
Les étapes de configuration décrit dans cette section sont tirées de la documentation officielle de PostGreSQL disponible ici <ulink url="http://docs.postgresqlfr.org/8.3/libpq-ssl.html">http://docs.postgresqlfr.org/8.3/libpq-ssl.html</ulink> (pour le client), et ici <ulink url="http://docs.postgresqlfr.org/8.3/ssl-tcp.html">http://docs.postgresqlfr.org/8.3/ssl-tcp.html</ulink> (pour le serveur). Les étapes de la procédure comportent :
<itemizedlist>
<listitem>
<para>
La vérification de la disponibilité du support d'OpenSSL dans PostGreSQL
</para>
</listitem>
<listitem>
<para>
La génération de certificats autosignés (optionnel)
</para>
</listitem>
<listitem>
<para>
L'activation du support SSL au niveau du serveur PostGreSQL
</para>
</listitem>
<listitem>
<para>
Le test de connexion en SSL
</para>
</listitem>
</itemizedlist>
</para>

<section>
<title>Vérifier que PostGreSQL a été compilé avec le support SSL</title>
<para>
Coté serveur, vous devez vérifier que le binaire <emphasis>postmaster</emphasis> est lié à la bibliothèque d'OpenSSL (<emphasis>libssl</emphasis>). Pour le faire, vous pouvez utiliser la commande suivante à partir d'une console.
</para>
<programlisting>
<![CDATA[
$ ldd /path/to/postmaster  | grep ssl
]]>
</programlisting>

<para>
De même, coté client, assurer vous que la bibliothèque <emphasis>libpq</emphasis> est liée à <emphasis>libssl</emphasis>. Pour le faire, vous pouvez utiliser la commande suivante à partir d'une console.
</para>
<programlisting>
<![CDATA[
$ ldd /path/to/libpq.so  | grep ssl
]]>
</programlisting>
<para>
Si toutes les vérifications sont correctes, vous pouvez passer à la configuration. Sinon vous devez reinstaller PostGreSQL en activant le support d'OpenSSL lors de la compilation (<literal>./configure --with-openssl</literal>).
</para>
</section>

<section>
<title>Activer le support SSL dans le serveur PostGreSQL</title>
<para>
L'activation du support SSL dans PostGreSQL est assez simple :
</para>
<para>
Premièrement, éditez le fichier de configuration (<literal>PostgreSQL.conf</literal>)et positionnez le paramètre <literal>ssl</literal> à <literal>on</literal>
</para>
<programlisting>
<![CDATA[
ssl=on
]]>
</programlisting>
<para>
Ensuite :
<itemizedlist>
<listitem>
<para>
Le certificat du serveur doit être nommé <literal>server.crt</literal> et placé dans le repertoire de données (<emphasis>data</emphasis>) de PostGreSQL. A noter que le fichier doit appartenir à l'utilisateur <emphasis>postgres</emphasis> et avoir les droits d'accès <literal>600</literal>.
</para>
</listitem>
<listitem>
<para>
La clé privé du certificat doit être nommée <literal>server.key</literal> et placée dans le repertoire de données (<emphasis>data</emphasis>) de PostGreSQL. Il doit également appartenir à l'utilisateur <emphasis>postgres</emphasis> et avoir les droits d'accès <literal>600</literal>.
</para>
</listitem>
<listitem>
<para>
Le fichier contenant les certificats de l'autorité doit est être nommé <literal>root.crt</literal> et placé dans le repertoire de données (<emphasis>data</emphasis>) de PostGreSQL. Il doit appartenir à l'utilisateur <emphasis>postgres</emphasis> et avoir les droits d'accès <literal>644</literal>.
</para>
</listitem>
</itemizedlist>
Si vous souhaitez avoir plus de détails ou mettre en oeuvre des configurations avancées comme la prise en charge des certificats revoqués, vous pouvez consulter la documentation officielle disponible à cette adresse <ulink url="http://docs.postgresqlfr.org/8.3/ssl-tcp.html">http://docs.postgresqlfr.org/8.3/ssl-tcp.html</ulink>.
</para>
<para>
Une fois les configurations terminées, redémarrez le serveur PostGreSQL.
</para>
</section>


<section>
<title>Tester la connexion en SSL à PostGreSQL</title>
<para>
Contrairement à MySQL, vous n'avez pas besoin d'avoir des droits spécifiques pour se connecter en SSL. Il vous suffit :
<itemizedlist>
<listitem>
<para>
Premièrement, de copier le fichier contenant les certificats de l'autorité dans l'emplacement <literal>~/.postgresql/root.crt</literal> depuis le dossier personnel de l'utilisateur. En notant que ce fichier doit avoir les droits d'accès <literal>644</literal>.
</para>
</listitem>
<listitem>
<para>
Ensuite, d'ajouter l'option <literal>"sslmode=verify-ca"</literal> lorsque vous vous connectez à PostGreSQL. Voir l'exemple ci-dessous.
</para>
</listitem>
</itemizedlist>
</para>

<programlisting>
<![CDATA[
$ psql -U postgres "sslmode=verify-ca"
]]>
</programlisting>
<para>
Si tout se passe bien, alors vous pouvez terminer la configuration en activant les options nécessaires dans VISHNU.
</para>
</section>
</section>
<section>
<title>Configurer VISHNU pour se connecter en SSL à une base de données</title>
<para>
Une fois MySQL ou PostGreSQL a été configuré pour fonctionner en SSL, il suffit d'ajouter les lignes suivantes dans le fichier de configuration de VISHNU pour indiquer les paramètres de connexion en SSL.
</para>
<programlisting>
<![CDATA[
databaseUseSsl=1
databaseSslCa=/opt/etc/sysfera/mysql-ssl/ca.pem
]]>
</programlisting>
<para>
Si le paramètre <emphasis>databaseUseSsl</emphasis> a une valeur non-nulle, on indique à VISHNU de se connecter à la base de données en mode chiffré. Optionnel, le paramètre<emphasis>databaseSslCa</emphasis> indique l'emplacement des certificats de l'autorité de confiance. Il n'est utile que dans le cas des certificats autosignés ou signés par une autorité de certification non reconnue. Pour PostGreSQL, l'option <emphasis>databaseSslCa</emphasis> peut ne pas être indiquée. Dans ce cas, le chemin par défaut (<literal>~/.postgresql/root.crt</literal>) sera considéré. 
</para>
<para>
Une fois la configuration terminée, redémarrez les services. Les communications avec la base de données se feront dorénavant en mode chiffré. 
</para>
</section>
</section>
</chapter>


<chapter>
<title>Administration</title>
<section>
<title>Présentation</title>
<para>
Le module UMS correspond à la gestion des utilisateurs et des machines de VISHNU. Il permet aussi de sauvegarder la configuration de VISHNU à chaud et de la restaurer si besoin est.
Dans toute la suite du chapitre, on supposera que l'utilisateur est déjà connecté avec un compte administrateur de VISHNU pour pouvoir réaliser ces manipulations. De plus, on présentera l'utilisation des commandes depuis le shell, mais cela reste valable depuis les API Python ou C++.
</para>
<para>L'API est disponible dans le document [VISHNU_API]</para>
</section>
<section>
<title>Gestion des utilisateurs (UMS)</title>
<orderedlist>
<listitem>
<para>
L'ajout d'un utilisateur se fait à l'aide de la commande 'vishnu_add_user'. Elle prend en paramètre le prénom de l'utilisateur, son nom de famille, les droits qui lui sont associés dans VISHNU (administrateur ou simple utilisateur) et son adresse de couriel. Tout ces paramètres sont obligatoires. Un privilège à 1 signifie administrateur, un privilège à 0 signifie un utilisateur. L'identifiant de l'utilisateur est généré et renvoyé.
</para>
</listitem>
<listitem>
<para>
La mise à jour d'un utilisateur ne peut être faite que par un administrateur. Cette mise à jour se fait avec un appel à la commande 'vishnu_update_user' et permet de modifier les paramètres de l'ajout (nom, prénom, statut, couriel).
Il faut avoir l'identifiant de l'utilisateur (généré lors de la création de l'utilisateur) pour le désigner lors de la mise à jour.
</para>
<para>Note : le changement du statut d'un utilisateur à l'état "INACTIVE" correspond à un blocage de son compte.</para>
</listitem>
<listitem>
<para>
La suppression d'un utilisateur efface toutes les informations liées à l'utilisateur de la base de donnée. Cette suppression se fait à l'aide de la commande 'vishnu_delete_user'.
</para>
</listitem>
<listitem>
<para>
La liste des utilisateurs ne peut être faite que par un administrateur. Cela se fait avec la commande 'vishnu_list_user'. Cette commande peut prendre en paramètre l'identifiant d'un utilisateur pour n'avoir les informations que concernant cet utilisateur.
</para>
</listitem>
<listitem>
<para>
Seul un administrateur peut réinitialiser le mot de passe d'un utilisateur de VISHNU. Pour ce faire, il doit appeller la commande 'vishnu_reset_password' en fournissant l'identifiant de l'utilisateur dont l'administrateur veut réinitialiser le mot de passe. Le nouveau mot de passe est temporaire et renvoyé par la commande. Lors de la prochaine connexion, l'utilisateur devra changer son mot de passe avec 'vishnu_change_password'.
</para>
</listitem>
</orderedlist>
</section>
<section>
<title>Gestion des machines (UMS+IMS)</title>
<orderedlist>
<listitem>
<para>L'ajout d'une machine se fait à l'aide de la commande 'vishnu_add_machine'. Cette commande prend en paramètre le nom de la machine, le site ou elle se trouve, le language de la description qui sera donnée pour la machine, le fichier contenant la clé publique et la description. Ces paramètres sont obligatoires, en passant par le shell, la description n'a pas besoin d'être fournie en paramètre mais elle est alors demandée à l'administrateur avant d'ajouter la machine. A la fin de l'ajout, l'identifiant généré pour la machine est renvoyé.</para>
</listitem>
<listitem>
<para>
La mise à jour d'une machine se fait à l'aide de la commande 'vishnu_update_machine' et permet de modifier les paramètres mis lors de l'ajout de la machine. Il faut utiliser l'identifiant de la machine pour l'identifier lors de la mise à jour.
</para>
<para>Note : le changement du statut d'une machine à l'état "INACTIVE" correspond à un blocage de la machine. Cela rend la machine inaccessible aux utilisateurs de VISHNU mais toujours visible pour les administrateurs.</para>
</listitem>
<listitem>
<para>
La suppression d'une machine se fait à l'aide de la commande 'vishnu_delete_machine' avec l'identifiant de la machine à supprimer. Cela supprime la machine de la base de données, ainsi que toutes les informations qui y sont attachées (Attention : cette commande est irréversible).
</para>
</listitem>
<listitem>
<para>
Les utilisateurs peuvent lister les machines, mais un administrateur a en plus une option qui est l'identifiant d'un utilisateur. Ceci lui permet de lister les machines sur lesquelles l'utilisateur a un compte VISHNU.
</para>
</listitem>
<listitem>
<para>
La mise à jour d'informations système d'une machine se fait à l'aide de la commande 'vishnu_set_system_info' et permet d'ajouter ou modifier des informations système d'une machine. Il faut utiliser l'identifiant de la machine pour l'identifier lors de la mise à jour.
</para>
</listitem>
</orderedlist>
</section>
<section>
<title>Gestion de la plateforme (UMS)</title>
<orderedlist>
<listitem>
<para>
L'administrateur peut faire une sauvegarde à chaud à un moment donné de VISHNU. Ceci sauvegarde les utilisateurs, les machines et les comptes des utilisateurs. Le fichier, dans lequel la configuration est, est retourné par la fonction. La fonction est 'vishnu_save_configuration', pas besoin de paramètres.
</para>
</listitem>
<listitem>
<para>
L'administrateur peut recharger une configuration précédente de VISHNU à l'aide de la commande 'vishnu_restore_configuration' qui a besoin du fichier de sauvegarde pour recharger la base.
Avant de pouvoir lancer cette restauration, tous les utilisateurs de VISHNU doivent être déconnectés.
</para>
</listitem>
<listitem>
<para>
Un administrateur peut également définir les valeurs par défaut des options de VISHNU pour tout les utilisateurs (ces options sont le temps de déconnexion par défaut et le type de fermeture d'une session par défaut). Cela se fait en appellant 'vishnu_configure_default_option' en donnant le nom de l'option et sa nouvelle valeur.
</para>
</listitem>
<listitem>
<para>
Un administrateur peut ajouter ou modifier un système d'authentification. Par exemple il peut ajouter différents LDAP pour authentifier ses utilisateurs. Actuellement, pour un même LDAP, si les utilisateurs sont dans des branches différentes il faut ajouter un système d'authentification par branche. Ceci afin de faciliter la connexion de l'utilisateur, pour qu'il ne donne aucune information concernant son arbre LDAP, juste son login. C'est l'administrateur lorsqu'il crée son système d'authentification qui doit remplir le champs ldapbase avec le chemin complet dans l'arbre LDAP à utiliser pour authentifier un utilisateur. Lorsqu'un administrateur rempli le chemin menant aux utilisateurs, il doit remplacer le nom de l'utilisateur par la chaîne de caractère \$USERNAME, cette chaîne sera remplacée par vishnu par le login de l'utilisateur que l'on cherche à authentifier.
Fonctions associées : vishnu_add_auth_system, vishnu_update_auth_system, vishnu_delete_auth_system
</para>
</listitem>
</orderedlist>
</section>
<section>
<title>Options propres à l'administrateur dans les commandes utilisateurs(UMS+FMS)</title>
<orderedlist>
<listitem>
<para>Dans la fonction 'vishnu_connect', un administrateur peut donner l'identifiant d'un utilisateur pour se connecter sous le nom de cet utilisateur dans VISHNU.</para>
</listitem>
<listitem>
<para>
Dans la fonction 'vishnu_list_history_cmd', l'administrateur peut lister toutes les commandes de tout les utilisateurs ou les commandes d'un utilisateur en particulier en fournissant l'identifiant de l'utilisateur.
</para>
</listitem>
<listitem>
<para>
Dans la fonction 'vishnu_list_local_accounts', l'administrateur peut lister toutes les comptes de tout les utilisateurs ou les comptes d'un utilisateur particulier en fournissant l'identifiant de l'utilisateur.
</para>
</listitem>
<listitem>
<para>
Dans la fonction 'vishnu_list_options', l'administrateur peut lister les toutes les options de tout les utilisateurs ou les options d'un utilisateur en particulier en fournissant l'identifiant de l'utilisateur.
</para>
</listitem>
<listitem>
<para>
Dans la fonction 'vishnu_list_sessions', l'administrateur peut lister les toutes les sessions de tous les utilisateurs ou les sessions d'un utilisateur en particulier en fournissant l'identifiant de l'utilisateur, ou les sessions sur une machine particulière en fournissant l'identifiant de la machine.
</para>
</listitem>
<listitem>
<para>
Dans la fonction 'vishnu_list_file_transfers', l'administrateur peut lister tous les transferts de fichiers de tous les utilisateurs ou ceux d'un utilisateur en particulier en fournissant l'identifiant de l'utilisateur, ou lister les transferts impliquant une machine particulière (qui peut être source ou destination du transfert) en fournissant l'identifiant de la machine.
</para>
</listitem>
<listitem>
<para>
Dans la fonction 'vishnu_stop_file_transfers', l'administrateur peut annuler tous les transferts de fichiers de tous les utilisateurs ou ceux d'un utilisateur en particulier en fournissant l'identifiant de l'utilisateur, ou annuler les transferts impliquant une machine particulière (qui peut être source ou destination du transfert) en fournissant l'identifiant de la machine.
</para>
</listitem>

</orderedlist>
</section>
<section>
<title>Gestion des processus VISHNU et délestage (IMS)</title>
<itemizedlist>
<listitem>
<para>
L'administrateur peut lister les processus VISHNU, sur toute la plateforme ou sur une machine particulière.
Fonction associée : vishnu_get_processes.
</para>
</listitem>
<listitem>
<para>
L'administrateur peut arrêter un processus VISHNU, ce processus ne sera pas redémarrer automatiquement.
Attention : l'administrateur doit avoir un compte sur la machine.
Fonction associée : vishnu_stop 
</para>
</listitem>
<listitem>
<para>
L'administrateur peut redémarrer un processus VISHNU sur une machine, ce processus doit avoir déjà tourné
pour VISHNU sur cette machine et l'administrateur doit avoir un compte sur la machine.
Fonction associée : vishnu_restart 
</para>
</listitem>
<listitem>
<para>L'administrateur peut délester une machine selon deux modes. Dans le mode HARD, tout les processus VISHNU
de la machine sont arretés. Dans le mode SOFT, seul FMS et TMS sont touchés, on arrête tout leurs transferts
et jobs en cours.
Fonction associée : vishnu_load_shed </para>
</listitem>
</itemizedlist>
</section>
<section>
<title>Surveillance de l'état des machines (IMS)</title>
<itemizedlist>
<listitem>
<para>Un administrateur peut fixer la fréquence de mise à jour de l'enregistrement de l'état des machines.
Fonction associée : vishnu_set_update_frequency</para>
</listitem>
<listitem>
<para>Un administrateur peut obtenir la fréquence de mise à jour de l'enregistrement de l'état des machines.
Fonction associée : vishnu_get_update_frequency</para>
</listitem>
<listitem>
<para>Un administrateur peut fixer un seuil sur une machine. Ce seuil peut être l'utilisation du CPU, la
mémoire libre restante ou l'espace disque restant. Lors de l'enregistrement de l'état d'une machine,
si un seuil est atteint sur cette machine, l'administrateur est notifié par mail de ce dépassement.
Fonction associée : vishnu_set_threshold</para>
</listitem>
<listitem>
<para>Un administrateur peut obtenir les seuils fixés sur une machine. Pour plus d'informations sur les seuils
voir la partie pour fixer les seuils ci-dessus.
Fonction associée : vishnu_get_threshold</para>
</listitem>
</itemizedlist>
</section>
<section>
<title>Définition des formats des identifiants (IMS)</title>
<itemizedlist>
<listitem>
<para>
Un administrateur peut fixer le format des identifiants VISHNU automatiquement générés pour les utilisateurs,
les machines, les jobs soumis aux batchs scheduler et les transferts de fichiers. Ces identifiants peuvent contenir
plusieurs variables :
<itemizedlist>
<listitem>
<para>
'$DAY' : Variable qui sera remplacée par le jour de création (1-31)
</para>
</listitem>
<listitem>
<para>
'$MONTH' : Variable qui sera remplacée par le mois de création (1-12)
</para>
</listitem>
<listitem>
<para>
'$YEAR' : Variable qui sera remplacé par l'année de création (0-99)
</para>
</listitem>
<listitem>
<para>
'$CPT' : Variable compteur qui est automatiquement incrémentée
</para>
</listitem>
<listitem>
<para>
'$SITE' : Pour les utilisateurs ou machine, une information sur le lieu
</para>
</listitem>
<listitem>
<para>
'$UNAME' : Pour les utilisateurs, variable remplacée par le nom de l'utilisateur
</para>
</listitem>
<listitem>
<para>
'$MANAME' : Pour les machines, variable remplacée par le nom de la machine
</para>
</listitem>
</itemizedlist>
Attention la variable compteur est obligatoire pour éviter la génération d'un identifiant déjà existant.
Fonctions associées : define_file_format, define_machine_format, define_task_format, define_user_format, define_auth_format.
</para>
</listitem>
</itemizedlist>
</section>
<section>
<title>FAQ</title>
<itemizedlist>
<listitem>
<para>Si vous rencontrez des problèmes lors du chargement des plugins TMS, vous pouvez configurez la variable d'environnement <emphasis role="italic">LD_LIBRARY_PATH</emphasis> pour pointer sur le répertoire contenant les plugins.</para>
</listitem>
</itemizedlist>
</section>
</chapter>

<chapter>
<title>Tests</title>
<para>
Les tests automatiques permettent de valider les fonctionnalités de VISHNU
et de garantir la non régression lors des développements. Le module de
test peut être activé au moment de la construction de VISHNU, en activant
la variable Cmake BUILD_TESTING. Le module de test sera donc compilé avec
les sources de vishnu.
</para>
<section>
<title>Tests unitaires</title>
<para>
un certain nombre de tests unitaires sont fournis avec VISHNU. Lorsque
vous compilez VISHNU avec BUILD_TESTING, ces tests sont construits et
présents dans le sous-répertoire bin de votre répertoire de build. Les
tests unitaires ont tous un nom terminant par UnitTests. Pour les
lancer, il suffit juste d'appeler le binaire. Pour voir les options
qu'il est possible de leur passer, vous pouvez lancer le binaire avec
l'option --help (ce sont les options du framework boost tests).
</para>
<para>
Ces tests ne nécessitent pas d'avoir une plateforme VISHNU déployée.
</para>
</section>
<section>
<title>Configuration des tests fonctionnels</title>
<para>
Lorsque
vous compilez Vishnu avec BUILD_TESTING, ces tests sont construits et
présents dans le sous-répertoire bin de votre répertoire de build. Les
tests fonctionnels ont tous un nom qui suit la nomenclature suivante:
&lt;nom du module&gt;_automTest&lt;numéro&gt; (e.g., fms_automTest11
pour la suite de test 11 du module FMS). Pour les
lancer, il suffit juste d'appeler le binaire. Pour voir les options
qu'il est possible de leur passer, vous pouvez lancer le binaire avec
l'option --help (ce sont les options du framework boost tests)
</para>
<para>
Ces tests, contrairement aux tests unitaires, nécessitent d'avoir une
plateforme VISHNU déployée. L'administrateur doit fournir un ensemble de
paramètres d'exécutions liés à la plateforme de test. Il est nécessaire
de positionner 2 variables d'environnement.
</para>
<section>
<title>Variables d'environnement et options de configuration</title>
<itemizedlist>
<listitem>
<para>
VISHNU_CLIENT_TEST_CONFIG_FILE : Variable qui contient le chemin
vers le fichier de configuration client. Ce fichier permet au
client VISHNU de se connecter à la plateforme (voir le manuel
utilisateur pour plus d'informations sur la configuration de ce fichier).
</para>
</listitem>
<listitem>
<para>
VISHNU_TEST_SETUP_FILE : Variable qui contient le chemin vers le
fichier de données de description de la plateforme. Ce fichier
permet aux tests automatiques de s'exécuter sur la plateforme. Ce
fichier doit contenir un ensemble de paramètres :
</para>
<itemizedlist>
<listitem>
<para>TEST_UMS_AUTHEN_TYPE : Contient le type de système d'authentification de la plateforme de test; </para>
</listitem>
<listitem>
<para>TEST_VISHNU_MACHINEID1 : Contient l'identifiant d'une machine VISHNU sur laquelle les tests UMS vont être exécutés; </para>
</listitem>
<listitem>
<para>TEST_WORKING_DIR : Contient le chemin vers le répertoire de travail local des tests; </para>
</listitem>
<listitem>
<para>TEST_ROOT_VISHNU_LOGIN : Contient le login VISHNU de l'utilisateur ROOT de la plateforme. L'utilisateur ROOT a les droits administrateur et a un Local Account sur chacune des machines de test; </para>
</listitem>
<listitem>
<para>TEST_ROOT_VISHNU_PWD : Contient le mot de passe VISHNU de l'utilisateur ROOT de la plateforme; </para>
</listitem>
<listitem>
<para>TEST_ADMIN_VISHNU_LOGIN : Contient le login VISHNU de l'administrateur de la plateforme. L'administrateur est un utilisateur qui a les droits administrateur et qui n'a aucun Local Account sur aucune des machines de test; </para>
</listitem>
<listitem>
<para>TEST_ADMIN_VISHNU_PWD : Contient le mot de passe VISHNU de l'administrateur de la plateforme; </para>
</listitem>
<listitem>
<para>TEST_USER_VISHNU_LOGIN : Contient le login VISHNU de l'utilisateur de test de la plateforme. L'utilisateur doit avoir un Local Account sur chacune des machines de test. Tout les test FMS et TMS sont exécutés en tant que l'utilistaeur TEST_USER_VISHNU_LOGIN; </para>
</listitem>
<listitem>
<para>TEST_USER_VISHNU_PWD : Contient le mot de passe VISHNU de l'utilisateur de test de la plateforme; </para>
</listitem>
<listitem>
<para>TEST_FMS_HOST1 : Contient l'identifiant de la première machine VISHNU sur laquelle les tests FMS vont être exécutés;</para>
</listitem>
<listitem>
<para>TEST_FMS_HOST2 : Contient l'identifiant de la deuxième machine VISHNU sur laquelle les tests FMS vont être exécutés; </para>
</listitem>
<listitem>
<para>TEST_FMS_HOST1_WORKING_DIR : Contient le chemin vers le répertoire de travail distant des tests FMS sur la machine TEST_FMS_HOST1. Ce répertoire accessible en lecture et ecriture par le Local Account de l'utilisateur TEST_USER_VISHNU_LOGIN sur la machine TEST_FMS_HOST1; </para>
</listitem>
<listitem>
<para>TEST_FMS_HOST2_WORKING_DIR : Contient le chemin vers le répertoire de travail distant des tests FMS sur la machine TEST_FMS_HOST2. Ce répertoire accessible en lecture et ecriture par le Local Account de l'utilisateur TEST_USER_VISHNU_LOGIN sur la machine TEST_FMS_HOST2; </para>
</listitem>
<listitem>
<para>TEST_FMS_USER_LOCAL_GROUP : Contient le groupe UNIX du Local Account de l'utilisateur TEST_USER_VISHNU_LOGIN sur la machine TEST_FMS_HOST1; </para>
</listitem>
<listitem>
<para>TEST_TMS_MACHINE_IDS : Contient la liste des machines TMS sur lesquelles les tests TMS vont êtres exécutés. Cette liste est constituée des couples: "&lt;identifiant de machine&gt; &lt;batch scheduler&gt;", séparé par des point-virgule. Exemple "TEST_TMS_MACHINE_IDS=machine_1 SLURM;machine_2 TORQUE" </para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section>
<title>Exemple de fichier de configuration</title>
<programlisting>
<![CDATA[
# This is a sample setup file for VISHNU tests
# Copyright (c) SysFera SA
# Last update: 04/02/2013
#


# Definitions
# FMS: File Management System
# IMS: Information Management System
# TMS: Task Management System
# UMS: User Management System


###############################################################################
#               Common Parameters                                             #
###############################################################################
TEST_VISHNU_MACHINEID1=machine_1
TEST_WORKING_DIR=/home/absila/machine_1
TEST_ROOT_VISHNU_LOGIN=root
TEST_ROOT_VISHNU_PWD=vishnu_user
TEST_ADMIN_VISHNU_LOGIN=admin_1
TEST_ADMIN_VISHNU_PWD=admin
TEST_USER_VISHNU_LOGIN=user_1
TEST_USER_VISHNU_PWD=toto


###############################################################################
#                UMS Related Parameters                                       #
###############################################################################
TEST_UMS_AUTHEN_TYPE=UMS

###############################################################################
#                FMS Specfic Parameters                                       #
###############################################################################
TEST_FMS_HOST1=machine_1
TEST_FMS_HOST2=machine_1
TEST_FMS_HOST1_WORKING_DIR=/home/absila/machine_2
TEST_FMS_HOST2_WORKING_DIR=/home/absila/machine_3
TEST_FMS_USER_LOCAL_GROUP=test;

###############################################################################
#                TMS Related Parameters                                       #
###############################################################################
TEST_TMS_MACHINE_IDS=machine_1 SLURM;machine_2 TORQUE

]]>
</programlisting>
</section>
<section>
<title>Prérequis</title>
<para>
Afin que les tests automatiques s'exécutent, la plateforme Vishnu doit
être fonctionnelle et les variable d'environnement renseignées. Tous
les paramètres du fichier VISHNU_TEST_SETUP_FILE doivent être
renseignés.
</para>
<para>
Les différentes machines de test peuvent être une seule et même machine (l'exemple de fichier ci-dessus fait référence à une seule machine).
</para>
</section>
<section>
<title>Rapport de test </title>
<para>
Les tests automatiques génèrent des rapports résumant le déroulement
du test ainsi que les résultats. Ces rapports peuvent être générés en
XML, pour cela il faut exécuter la commande suivante : "make
test_name-xml" en remplaçant test_name par le nom du test à exécuter
(e.g., fms_automTest1). Ce format XML est pratique pour intégrer les
résultats de test dans votre environnement d'intégration continue tel
que Jenkins.
</para>
</section>
</section>
</chapter>
</book>
